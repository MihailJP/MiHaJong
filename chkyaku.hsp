/*=============================
 * HSP麻雀クライアントMiHaJong
 *      [役判定ルーチン]
 *=============================
 */

#include "ystruct.as"

/* 役を判定する */
#module
#include "const.as"
#include "hspmath.as"
#deffunc countyaku var GameStat, var yakuInfo, int targetPlayer
	debug strf("役判定処理を開始 プレイヤー [%d]", targetPlayer)
	if (vartype(yakuInfo) == vartype("struct")) {
		if (varuse(yakuInfo)) {
			delmod yakuInfo
		}
	}
	newmod yakuInfo, yakuStruct
	chkfuriten FuritenFlag, MachihaiFlag, MachihaiCount, MachihaiTotal, MachiMen, GameStat, targetPlayer
	dim MianziDat, SIZE_OF_MELD_BUFFER
	dim ShantenArray, SHANTEN_PAGES
	repeat SHANTEN_PAGES: ShantenArray(cnt) = countshanten(GameStat, targetPlayer, cnt): loop
	Shanten = ShantenArray(SHANTEN_ALL)
	if (Shanten > -1) {
		trace "和了っていないので抜けます"
		return
	}
	repeat 160
		dim tmpScore, NUM_OF_DIGIT_GROUPS
		//if ((cnt \ 8) == 7) {await 0}
		newmod tmpYakuInfo, yakuStruct
		if (cnt == 0) {
#ifndef SANMAS
			/* 国士無双 */
			if (ShantenArray(SHANTEN_ORPHANS) == -1) {
				contextualyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, MachiType
				shisanyaoyaku GameStat, tmpYakuInfo, targetPlayer, FuritenFlag
				countdora GameStat, tmpYakuInfo, targetPlayer
			}
			/* 七星無靠 */
			if (getRule(RULE_STELLAR_UUSHII) != 0) {
				if (ShantenArray(SHANTEN_STELLAR) == -1) {
					contextualyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, MachiType
					if (getRule(RULE_STELLAR_UUSHII) == 2) {
						addmangan tmpYakuInfo, "七星無靠", 2
					} else {
						addyakuman tmpYakuInfo, "七星無靠", 1
					}
					countdora GameStat, tmpYakuInfo, targetPlayer
				}
			}
			/* 南北戦争 */
			if (getRule(RULE_CIVIL_WAR) != 0) {
				if (ShantenArray(SHANTEN_CIVILWAR) == -1) {
					contextualyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, MachiType
					addyakuman tmpYakuInfo, "南北戦争", 1
					countdora GameStat, tmpYakuInfo, targetPlayer
				}
			}
#endif
			/* 惑星直列 */
			if (getRule(RULE_SYZYGY) != 0) {
				if (ShantenArray(SHANTEN_SYZYGY) == -1) {
					contextualyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, MachiType
					if ((TsumoTile(GameStat, targetPlayer) \ 2) == 0) {
						addyakuman tmpYakuInfo, "惑星直列", 2
					} else {
						addyakuman tmpYakuInfo, "惑星直列", 1
					}
					countdora GameStat, tmpYakuInfo, targetPlayer
				}
			}
			/* 七対子 */
			if ((ShantenArray(SHANTEN_PAIRS) == -1)&&(ShantenArray(SHANTEN_REGULAR) != -1)) {
				contextualyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, MachiType
				qiduiyaku GameStat, tmpYakuInfo, targetPlayer
				countdora GameStat, tmpYakuInfo, targetPlayer
			}
		}
		/* 面子手ここから */
		AtamaCode = cnt
		makementsu GameStat, tmpYakuInfo, targetPlayer, Atamacode, ProcessedTiles, MianziDat
		if (ProcessedTiles == SIZE_OF_MELD_BUFFER) {
			trace strf("面子を検出 プレイヤー [%d] モード [%d] 面子データ [%d %d %d %d %d]", targetPlayer, AtamaCode\4, MianziDat(0), MianziDat(1), MianziDat(2), MianziDat(3), MianziDat(4))
			contextualyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, MachiType
			calcbasepoints GameStat, tmpYakuInfo, MianziDat, targetPlayer, MachiType
			suityaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, FuritenFlag, MachiType
			yaojiuyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer
			tripletyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, FuritenFlag, MachiType
			quadyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer
			sequenceyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, MachiType
			miscyaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, MachiType
			setYakuInfo tmpYakuInfo, YAKUINF_FU, ((getYakuInfo(tmpYakuInfo, YAKUINF_FU)+8)/10)*10 // 点パネする
			countdora GameStat, tmpYakuInfo, targetPlayer
			posterioryaku GameStat, tmpYakuInfo, MianziDat, targetPlayer, MachiType
		} else: if (cnt > 0) {
			delmod tmpYakuInfo
			continue
		}
		tmpScore(0) = getYakuInfo(tmpYakuInfo, YAKUINF_FU)
		if (getRule(RULE_SIMPLIFIED_SCORING) != 0) {
			trace "簡略計算ルールのため30符として扱います。"
			tmpScore(0) = 30: setYakuInfo tmpYakuInfo, YAKUINF_FU, 30 /* 簡略計算用 */
		}
		calculateScore tmpYakuInfo, tmpScore
#ifndef SANMAS
		/* 十三不塔の判定 */
		shisanbudayaku GameStat, tmpYakuInfo, targetPlayer, tmpScore, ShantenArray
		/* 十四不塔の判定 */
		shisibudayaku GameStat, tmpYakuInfo, targetPlayer, tmpScore, ShantenArray
#endif
		
		if ((getRule(RULE_ROUND_TO_MANGAN) == 1)&&(getRule(RULE_LIMITLESS) == 0)) {
			// 切り上げ満貫
			if (tmpScore(0) == 1920) {tmpScore(0) = 2000}
		}
		// 青天井対応の高点法の処理
		bignum_duplicate tmpDiff, tmpScore, 0
		exportYakuPoint YakuInfo, scoreArray
		bignum_subtract tmpDiff, scoreArray, 0, 100000000
		tmpComparison = bignum_flag(tmpDiff, 0)
		if ((tmpComparison == 1)||((tmpComparison == 0)&&(getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE) > getYakuInfo(yakuInfo, YAKUINF_HAN_BASE)))) {
			setYakuInfo yakuInfo, YAKUINF_FU, getYakuInfo(tmpYakuInfo, YAKUINF_FU)
			setYakuInfo yakuInfo, YAKUINF_HAN_BASE, getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)
			setYakuInfo yakuInfo, YAKUINF_HAN_BONUS, getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)
			setYakuInfo yakuInfo, YAKUINF_DORA, getYakuInfo(tmpYakuInfo, YAKUINF_DORA)
			setYakuInfo yakuInfo, YAKUINF_URADORA, getYakuInfo(tmpYakuInfo, YAKUINF_URADORA)
			setYakuInfo yakuInfo, YAKUINF_AKADORA, getYakuInfo(tmpYakuInfo, YAKUINF_AKADORA)
			setYakuInfo yakuInfo, YAKUINF_AODORA, getYakuInfo(tmpYakuInfo, YAKUINF_AODORA)
			setYakuInfo yakuInfo, YAKUINF_ALICEDORA, getYakuInfo(tmpYakuInfo, YAKUINF_ALICEDORA)
			setYakuInfo yakuInfo, YAKUINF_FLOWER, getYakuInfo(tmpYakuInfo, YAKUINF_FLOWER)
			repeat NUM_OF_DIGIT_GROUPS
				setYakuInfo yakuInfo, YAKUINF_POINTS+cnt, tmpScore(cnt)
			loop
			omoteDoraQuantity = getYakuInfo(tmpYakuInfo, YAKUINF_DORA)-getYakuInfo(tmpYakuInfo, YAKUINF_URADORA)-getYakuInfo(tmpYakuInfo, YAKUINF_FLOWER)
			if (getRule(RULE_REDTILE_CHIP) < 3) {omoteDoraQuantity -= getYakuInfo(tmpYakuInfo, YAKUINF_AKADORA)}
			switch getRule(RULE_BLUE_TILES)
				case 0: omoteDoraQuantity -= getYakuInfo(tmpYakuInfo, YAKUINF_AODORA): swbreak
				case 1: omoteDoraQuantity -= getYakuInfo(tmpYakuInfo, YAKUINF_AODORA)*2: swbreak
				case 2: omoteDoraQuantity += getYakuInfo(tmpYakuInfo, YAKUINF_AODORA): swbreak
			swend
			addquan tmpYakuInfo, "ドラ ", omoteDoraQuantity
#ifdef SANMAX
			addquan tmpYakuInfo, "ガリ ", getYakuInfo(tmpYakuInfo, YAKUINF_FLOWER)
#else
			addquan tmpYakuInfo, "花牌 ", getYakuInfo(tmpYakuInfo, YAKUINF_FLOWER)
#endif
			if (getRule(RULE_REDTILE_CHIP) < 3) {addquan tmpYakuInfo, "赤ドラ ", getYakuInfo(tmpYakuInfo, YAKUINF_AKADORA)}
			switch getRule(RULE_BLUE_TILES)
				case 0: addquan tmpYakuInfo, "青ドラ ", getYakuInfo(tmpYakuInfo, YAKUINF_AODORA): swbreak
				case 1: addquan tmpYakuInfo, "青ドラ 2x", getYakuInfo(tmpYakuInfo, YAKUINF_AODORA): swbreak
				case 2: addquan tmpYakuInfo, "青ドラ -", getYakuInfo(tmpYakuInfo, YAKUINF_AODORA): swbreak
			swend
			addquan tmpYakuInfo, "裏ドラ ", getYakuInfo(tmpYakuInfo, YAKUINF_URADORA)
			addquan tmpYakuInfo, "アリス祝儀 ", getYakuInfo(tmpYakuInfo, YAKUINF_ALICEDORA)
			setYakuInfoTxt yakuInfo, YAKUINF_YAKULIST, getYakuInfo(tmpYakuInfo, YAKUINF_YAKULIST)
			setYakuInfoTxt yakuInfo, YAKUINF_YAKUVALLIST, getYakuInfo(tmpYakuInfo, YAKUINF_YAKUVALLIST)
			setYakuInfoTxt yakuInfo, YAKUINF_YAKUMANLIST, getYakuInfo(tmpYakuInfo, YAKUINF_YAKUMANLIST)
		}
		delmod tmpYakuInfo
		if (ShantenArray(SHANTEN_REGULAR) != -1) {break /* 面子手の和了りじゃないなら判定は1回でいい */}
	loop
return
#global

/* 青天井ルールの点数計算処理 */
#module
#include "const.as"
#include "hspmath.as"
#deffunc calculateScore var tmpYakuInfo, array tmpScore
	if (getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE) <= 0) {tmpScore(0) = 0: return}
	if (getRule(RULE_LIMITLESS) == 0) {
		// 通常ルール
		tmpTotalHan = getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)+getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)+getYakuInfo(tmpYakuInfo, YAKUINF_DORA)+getYakuInfo(tmpYakuInfo, YAKUINF_ALICEDORA)
		tmpXTotalHan = (tmpTotalHan+YAKUVAL_MINUS_LIMIT)\YAKUVAL_HALFMANGAN-YAKUVAL_MINUS_LIMIT
		tmpTotalMangan = (tmpTotalHan+YAKUVAL_MINUS_LIMIT)/YAKUVAL_HALFMANGAN
		if ((tmpTotalMangan < 3)&&(tmpXTotalHan < 6)) {
			tmpScore(0) = int(ceil(double(getYakuInfo(tmpYakuInfo, YAKUINF_FU))*powf(2, tmpXTotalHan+2)))
			if ((tmpTotalMangan == 2)||(tmpScore(0) > 2000)) {tmpScore(0) = 2000}
		} else: if ((tmpTotalMangan < 4)&&(tmpXTotalHan < 8)) {
			tmpScore(0) = 3000
		} else: if ((tmpTotalMangan < 6)&&((tmpXTotalHan < 10)||((tmpXTotalHan < 11)&&(getRule(RULE_SANBAIMAN_BORDER) == 0)))) {
			tmpScore(0) = 4000
		} else: if ((tmpTotalMangan < 8)&&((tmpXTotalHan < 12)||((tmpXTotalHan < 13)&&(getRule(RULE_KAZOE_BORDER) == 0))||((tmpXTotalHan < (YAKUVAL_YAKUMAN-YAKUVAL_MINUS_LIMIT))&&(getRule(RULE_KAZOE_BORDER) == 2)))) {
			tmpScore(0) = 6000
		} else {
			tmpScore(0) = 8000
			if (tmpTotalHan >= (YAKUVAL_YAKUMAN-YAKUVAL_MINUS_LIMIT)) {
				tmpScore(0) = ((tmpTotalHan+YAKUVAL_MINUS_LIMIT)/YAKUVAL_YAKUMAN)*8000
			}
		}
	} else {
		// 青天井ルール
		if ((getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)+getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)) >= YAKUVAL_YAKUMAN) {
			// 役満は固定点にするルール
			tmpScore(0) = 2500000
		} else:if ((getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)+getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)) >= YAKUVAL_SANBAIMAN) {
			tmpScore(0) = 1875000
		} else:if ((getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)+getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)) >= YAKUVAL_BAIMAN) {
			tmpScore(0) = 1250000
		} else:if ((getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)+getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)) >= YAKUVAL_HANEMAN) {
			tmpScore(0) = 937500
		} else:if ((getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)+getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)) >= YAKUVAL_MANGAN) {
			tmpScore(0) = 625000
		} else:if ((getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)+getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)+getYakuInfo(tmpYakuInfo, YAKUINF_DORA)+getYakuInfo(tmpYakuInfo, YAKUINF_ALICEDORA)) <= 0) {
			tmpScore(0) = int(ceil(double(getYakuInfo(tmpYakuInfo, YAKUINF_FU))*powf(2, (getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)+getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)+getYakuInfo(tmpYakuInfo, YAKUINF_DORA)+getYakuInfo(tmpYakuInfo, YAKUINF_ALICEDORA))+2)))
		} else {
			tmpScore(0) = getYakuInfo(tmpYakuInfo, YAKUINF_FU)*4
			repeat (getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)+getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)+getYakuInfo(tmpYakuInfo, YAKUINF_DORA)+getYakuInfo(tmpYakuInfo, YAKUINF_ALICEDORA))
				// 符号つき32ビット型ではダブル役満程度でも簡単にオーバーフローしてしまう
				// 変数を8つ用意し64桁まで用意しておく
				if (getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE)+getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BONUS)+getYakuInfo(tmpYakuInfo, YAKUINF_DORA)+getYakuInfo(tmpYakuInfo, YAKUINF_ALICEDORA) == 0) {break}
				bignum_multiply tmpScore, 2, 0, 100000000
			loop
		}
	}
	trace strf("計算結果は [%08d %08d %08d %08d %08d %08d %08d %08d]", tmpScore(7), tmpScore(6), tmpScore(5), tmpScore(4), tmpScore(3), tmpScore(2), tmpScore(1), tmpScore(0))
	return
#global

/* 役を成立させる */
#module
#include "const.as"
#deffunc addyaku var tmpYakuInfo, str yakuName, int yakuVal
/*
		addyaku p1, p2, p3
		役を成立させる

		p1 : 役情報を格納した構造体
		p2 : 追加する役の名前
		p3 : 追加する飜

		成立している役のリストに役を追加します。
*/
	tmpDigit = "０１２３４５６７８９"
	addYakuInfo tmpYakuInfo, YAKUINF_HAN_BASE, yakuVal
	addYakuInfoTxt tmpYakuInfo, YAKUINF_YAKULIST, yakuName+"\n"
	if ((yakuVal >= 0)&&(yakuVal < 10)) {addYakuInfoTxt tmpYakuInfo, YAKUINF_YAKUVALLIST, strmid(tmpDigit, yakuVal*2, 2)+"飜\n"}
	else {addYakuInfoTxt tmpYakuInfo, YAKUINF_YAKUVALLIST, ""+yakuVal+"飜\n"}
	trace strf("役を追加 [%s] 、 [%d] 飜、累計 [%d]",yakuName, yakuVal, getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE))
	return
#global

#module
#include "const.as"
#deffunc addquan var tmpYakuInfo, str yakuName, int yakuVal
/*
		addquan p1, p2, p3
		ドラの数をリストに反映させる

		p1 : 役情報を格納した構造体
		p2 : 追加する役の名前
		p3 : 追加する飜

		成立している役のリストにドラの数を追加します。
*/
	if (yakuVal > 0) {
		tmpDigit = "０１２３４５６７８９"
		if (yakuVal < 10) {addYakuInfoTxt tmpYakuInfo, YAKUINF_YAKULIST, yakuName+strmid(tmpDigit, yakuVal*2, 2)+"\n"}
		else {addYakuInfoTxt tmpYakuInfo, YAKUINF_YAKULIST, yakuName+yakuVal+"\n"}
		addYakuInfoTxt tmpYakuInfo, YAKUINF_YAKUVALLIST, "\n"
		trace strf("リストに追加 [%s] 、 [%d] 飜",yakuName, yakuVal)
	}
	return
#global

/* 役満を成立させる */
#module
#include "const.as"
#deffunc addyakuman var tmpYakuInfo, str yakuName, int yakuVal
/*
		addyakuman p1, p2, p3
		役満を成立させる

		p1 : 役情報を格納した構造体
		p2 : 追加する役の名前
		p3 : 追加する役満の倍率(1=シングル役満、2=ダブル役満…)

		成立している役満のリストに役を追加します。
*/
	if (getRule(RULE_LIMITLESS) == 2) {
		addyaku tmpYakuInfo, yakuName, yakuVal*13
	} else {
		addYakuInfo tmpYakuInfo, YAKUINF_HAN_BASE, yakuVal*YAKUVAL_YAKUMAN
		addYakuInfoTxt tmpYakuInfo, YAKUINF_YAKUMANLIST, yakuName+"\n"
		addYakuInfoTxt tmpYakuInfo, YAKUINF_YAKUMANVALLIST, ""+(yakuVal*YAKUVAL_YAKUMAN)+"\n"
		trace strf("役を追加 [%s] 、 [%d] 倍役満、累計 [%d]",yakuName, yakuVal, getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE))
	}
	return
#global

/* 満貫を成立させる */
#module
#include "const.as"
#deffunc addmangan var tmpYakuInfo, str yakuName, int yakuVal
/*
		addmangan p1, p2, p3
		満貫(跳満、倍満、三倍満)を成立させる

		p1 : 役情報を格納した構造体
		p2 : 追加する役の名前
		p3 : 追加する満貫(2=満貫、3=跳満、4=倍満、6=三倍満)

		成立している役満のリストに役を追加します。
*/
	if (getRule(RULE_LIMITLESS) == 2) {
		switch yakuVal
			case 2: addyaku tmpYakuInfo, yakuName, 5: swbreak
			case 3: addyaku tmpYakuInfo, yakuName, 6: swbreak
			case 4: addyaku tmpYakuInfo, yakuName, 8: swbreak
			case 6: addyaku tmpYakuInfo, yakuName, 11: swbreak
			case 8: addyakuman tmpYakuInfo, yakuName, 1: swbreak
			case 16: addyakuman tmpYakuInfo, yakuName, 2: swbreak
		swend
		addyaku tmpYakuInfo, yakuName, yakuVal*13
	} else {
		switch yakuVal
			case 2: case 3: case 4: case 6: gosub *doaddmangan: swbreak
			case 8: addyakuman tmpYakuInfo, yakuName, 1: swbreak
			case 16: addyakuman tmpYakuInfo, yakuName, 2: swbreak
		swend
	}
	return
	
*doaddmangan
	addYakuInfo tmpYakuInfo, YAKUINF_HAN_BASE, yakuVal*YAKUVAL_HALFMANGAN
	addYakuInfoTxt tmpYakuInfo, YAKUINF_YAKUMANLIST, yakuName+"\n"
	addYakuInfoTxt tmpYakuInfo, YAKUINF_YAKUMANVALLIST, ""+(yakuVal*YAKUVAL_HALFMANGAN)+"\n"
	trace strf("役を追加 [%s] 、 [%.1f] 倍満貫、累計 [%d]",yakuName, double(yakuVal)/2.0, getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE))
	return
#global

/* 役の成立を解除 */
#module
#include "const.as"
#deffunc delyaku var tmpYakuInfo, str tmpyakuDelete
/*
		delyaku p1, p2
		役の成立を取り消す

		p1 : 役情報を格納した構造体
		p2 : 削除したい役の名前

		成立している役のリストから指定した役を削除します。
*/
	tmpYakuName = getYakuInfo(tmpYakuInfo, YAKUINF_YAKULIST)
	tmpYakuVal = getYakuInfo(tmpYakuInfo, YAKUINF_YAKUVALLIST)
	targetLine = notesearch(tmpYakuName, tmpyakuDelete)
	if (targetLine >= 0) {
		notesel tmpYakuVal: noteget tmpValXX, targetLine: noteunsel
		tmpDeleteHan = 0
		tmpValXXX = strmid(tmpValXX, 0, 2)
		switch tmpValXXX
			case "９": tmpDeleteHan++ /* FALLTHRU */
			case "８": tmpDeleteHan++ /* FALLTHRU */
			case "７": tmpDeleteHan++ /* FALLTHRU */
			case "６": tmpDeleteHan++ /* FALLTHRU */
			case "５": tmpDeleteHan++ /* FALLTHRU */
			case "４": tmpDeleteHan++ /* FALLTHRU */
			case "３": tmpDeleteHan++ /* FALLTHRU */
			case "２": tmpDeleteHan++ /* FALLTHRU */
			case "１": tmpDeleteHan++: swbreak
			case "０": /* do nothing */: swbreak
			default:
			tmpDeleteHan = int(tmpValXXX)
		swend
		notesel tmpYakuName: notedel targetLine: noteunsel
		notesel tmpYakuVal: notedel targetLine: noteunsel
		setYakuInfoTxt tmpyakuInfo, YAKUINF_YAKULIST, tmpYakuName
		setYakuInfoTxt tmpyakuInfo, YAKUINF_YAKUVALLIST, tmpYakuVal
		addYakuInfo tmpYakuInfo, YAKUINF_HAN_BASE, -tmpDeleteHan
		trace strf("役を削除 [%s] 、 [%d] 飜、累計 [%d]",tmpyakuDelete, tmpDeleteHan, getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE))
	}
	return
#global


/* 役満の成立を解除 */
#module
#include "const.as"
#deffunc delyakuman var tmpYakuInfo, str tmpyakuDelete
/*
		delyakuman p1, p2
		役満の成立を取り消す

		p1 : 役情報を格納した構造体
		p2 : 削除したい役の名前

		成立している役満のリストから指定した役を削除します。
*/
	tmpYakuName = getYakuInfo(tmpYakuInfo, YAKUINF_YAKUMANLIST)
	tmpYakuVal = getYakuInfo(tmpYakuInfo, YAKUINF_YAKUMANVALLIST)
	targetLine = notesearch(tmpYakuName, tmpyakuDelete)
	if (targetLine >= 0) {
		notesel tmpYakuVal: noteget tmpValXX, targetLine: noteunsel
		tmpDeleteHan = int(tmpValXX)
		notesel tmpYakuName: notedel targetLine: noteunsel
		notesel tmpYakuVal: notedel targetLine: noteunsel
		setYakuInfoTxt tmpyakuInfo, YAKUINF_YAKUMANLIST, tmpYakuName
		setYakuInfoTxt tmpyakuInfo, YAKUINF_YAKUMANVALLIST, tmpYakuVal
		addYakuInfo tmpYakuInfo, YAKUINF_HAN_BASE, -tmpDeleteHan*YAKUVAL_HALFMANGAN
		trace strf("役を削除 [%s] 、 [%.1f] 倍満貫、累計 [%d]",tmpyakuDelete, double(tmpDeleteHan)/2.0, getYakuInfo(tmpYakuInfo, YAKUINF_HAN_BASE))
	}
	return
#global

/* 役が成立しているかを判定 */
#module
#include "const.as"
#defcfunc searchyaku var tmpYakuInfo, str tmpCheckingYaku
/*
		val=searchyaku(p1, p2)
		役が成立しているかを判定する

		p1 : 役情報を格納した構造体
		p2 : 成立しているかを判定する役の名前

		指定した役が既に成立しているかを判定します。
		既に成立していれば1、そうでなければ0を返します。
*/
	tmpyakuCensored = 0
	tmpYakuName = getYakuInfo(tmpYakuInfo, YAKUINF_YAKULIST)
	tmpYakumanName = getYakuInfo(tmpYakuInfo, YAKUINF_YAKUMANLIST)
	if (notesearch(tmpYakuName, tmpCheckingYaku) >= 0) {tmpyakuCensored = 1}
	if (notesearch(tmpYakumanName, tmpCheckingYaku) >= 0) {tmpyakuCensored = 1}
	return tmpyakuCensored
#global

/* 国士無双の判定 */
#ifndef SANMAS
#include "chk-13y.hsp"
#endif
/* 七対子の判定 */
#include "chk-7par.hsp"
/* 手牌を面子に分解 */
#include "chk-mntz.hsp"
/* 符計算、平和 */
#include "chk-pnkt.hsp"
/* 状況役 */
#include "chk-cond.hsp"
/* 一色系などの役 */
#include "chk-suit.hsp"
/* タンヤオ、チャンタなどの役 */
#include "chk-yao.hsp"
/* 刻子系の役 */
#include "chk-trpl.hsp"
/* 槓子系の役 */
#include "chk-quad.hsp"
/* 順子系の役 */
#include "chk-seq.hsp"
/* その他の役 */
#include "chk-misc.hsp"
/* 十三不塔 */
#include "chk-buda.hsp"
/* ドラ */
#include "chk-dora.hsp"
/* 後回しの役 */
#include "chk-post.hsp"
