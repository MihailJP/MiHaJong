/*=============================
 * HSP麻雀クライアントMiHaJong
 *    [雑多なサブルーチン]
 *=============================
 */

/* デバッグログ */
#module debuglog
#include "const.as"
#deffunc loginit
#ifdef LOGGING
	verbosity_level = "FATAL","ERROR","WARN","INFO","DEBUG","TRACE"
	verbosity_border = 5
	sdim filename, 1024
	gsel 0
	logdir = confPath()
	if (logdir == "") {logdir = "."}
	filename = logdir+"\\debug.log"
	exec "logger.exe "+PORT_LOGGER+"/"+filename
	repeat 1
		sockopen@ SOCK_LOGGER,"127.0.0.1",PORT_LOGGER
		if (stat) {await 0: continue 0}
	loop
#endif
return

#deffunc debug_logging str debugmsg, str debugfile, int debugline, int verbosity
#ifdef LOGGING
	if (verbosity > verbosity_border) {return}
	sdim log, 1024
	log = strf("%04d-%02d-%02d %02d:%02d:%02d.%03d %-5s (%s:%d) %s\n", gettime(0),gettime(1),gettime(3),gettime(4),gettime(5),gettime(6),gettime(7), verbosity_level(verbosity),debugfile,debugline,debugmsg)
	sockputb@ log, 0, strlen(log), SOCK_LOGGER
#endif
return
#global

#module
#include "hspmath.as"
#defcfunc julian int year, int month, int day, int hour, int min, int sec, int msec
/*
		val=julian(p1, p2, p3, p4, p5, p6, p7)
		ユリウス日を計算する

		p1 : 年
		p2 : 月
		p3 : 日
		p4 : 時
		p5 : 分
		p6 : 秒
		p7 : ミリ秒

		指定した日時のユリウス日を求めます。
*/
	if (month < 3) {
		JulianDay = floor(365.25*double(year-1))+floor(double(year-1)/400)-floor(double(year-1)/100)+floor(30.59*(double(month)+10))+double(day)-678912+2400000.5
	} else {
		JulianDay = floor(365.25*double(year))+floor(double(year)/400)-floor(double(year)/100)+floor(30.59*(double(month)-2))+double(day)-678912+2400000.5
	}
	JulianDay += double(hour)/24+double(min)/24/60+double(sec)/24/3600+double(msec)/24/3600/1000-0.5
	return JulianDay
#global


#module
#defcfunc notesearch array tmpnote, str txt
/*
		val=notesearch(p1, p2)
		文字列バッファから特定の文字列を検索する

		p1 : 検索されるバッファ
		p2 : 検索する文字列

		指定したバッファから特定の文字列になっている行を検索し、見つかった行を返します。
		見つからなかった場合は-1を返します。
*/
	ans=-1
	notesel tmpnote
	repeat notemax
		noteget a, cnt
		if (a == txt) {ans = cnt: break}
	loop
	noteunsel
	return ans
#global

/* メニュー画面の背景を表示 */
#module
#include "const.as"
#deffunc menubgcolor
#ifdef SANMAS
	color 64, 0, 64
#else
#ifdef SANMA4
	color 0, 64, 64
#else
#ifdef SANMA
	color 0, 0, 64
#else
	color 0, 64, 0
#endif
#endif
#endif
	return
#deffunc showbackground
	menubgcolor
	boxf 0, 0, 839, 629
	gmode gmode_pixela: pos 0, 0: gcopy SCR_TITLE_BACKGROUND, 0, 0, 840, 630: gmode gmode_mem
	return
#global

/* 縁取りテキスト */
#module
#include "const.as"
#deffunc borderedtxt str BorderText, int BorderTextX, int BorderTextY, int BorderTextR, int BorderTextG, int BorderTextB
/*
		borderedtxt p1, p2, p3, p4, p5, p6
		縁取りテキストを表示する

		p1 : 表示する文字列
		p2 : 表示するX座標
		p3 : 表示するY座標
		p4 : 文字の色の赤成分
		p5 : 文字の色の緑成分
		p6 : 文字の色の青成分

		文字列を縁取りして表示します。
*/
	BorderThickness = 1
	TextSize = 0: TextWidthRate = 1.0
	gosub *doputtext
return

#deffunc borderedtxt2 str BorderText, int BorderTextX, int BorderTextY, int BorderTextR, int BorderTextG, int BorderTextB, \
int BorderThickness_, int TextSize_, int GradR, int GradG, int GradB, int Style
	BorderThickness = BorderThickness_
	TextSize = TextSize_: TextWidthRate = 1.0
	gosub *doputtext
return

#deffunc borderedtxt3 str BorderText, int BorderTextX, int BorderTextY, int BorderTextR, int BorderTextG, int BorderTextB, \
int BorderThickness_, int TextSize_, int GradR, int GradG, int GradB, int Style, \
double TextWidthRate_
	BorderThickness = BorderThickness_
	TextSize = TextSize_: TextWidthRate = TextWidthRate_
	gosub *doputtext
return

*doputtext
	if (TextSize) {font fontname, TextSize, Style}
	color 0, 0, 0
	repeat BorderThickness*2+1
		BorderOffsetY = cnt-BorderThickness
		repeat BorderThickness*2+1
			BorderOffsetX = cnt-BorderThickness
			if ((BorderOffsetX*BorderOffsetX+BorderOffsetY*BorderOffsetY) <= (BorderThickness*BorderThickness+BorderThickness/2)) {
				if (TextWidthRate != 1.0) {
					tmpscr = ginfo_sel
					buffer SCR_TEXT_RESIZE_BUF, 1200, TextSize: gsel SCR_TEXT_RESIZE_BUF
					color 0, 0, 0: boxf 0, 0, 1199, TextSize-1
					color 255, 255, 255: pos 0, 0: font fontname, TextSize, Style: print BorderText
					buffer SCR_TEXT_BUF, 1200, TextSize: gsel SCR_TEXT_BUF
					color 0, 0, 0: boxf 0, 0, 1199, TextSize-1
					color 255, 255, 255: pos 600, 0
					gzoom int(1200.0*TextWidthRate), TextSize, SCR_TEXT_RESIZE_BUF, 0, 0, 1200, TextSize, 1
					gsel tmpscr: pos BorderTextX+BorderOffsetX, BorderTextY+BorderOffsetY: gmode gmode_pixela, 600, TextSize
					gcopy SCR_TEXT_BUF, 0, 0, 600, TextSize
					gmode gmode_mem
				} else {
					pos BorderTextX+BorderOffsetX, BorderTextY+BorderOffsetY: print BorderText
				}
			}
		loop
	loop
	if (TextSize) {
		tmpscr = ginfo_sel
		if (TextWidthRate != 1.0) {
			buffer SCR_TEXT_RESIZE_BUF, 1200, TextSize: gsel SCR_TEXT_RESIZE_BUF
			color 0, 0, 0: boxf 0, 0, 1199, TextSize-1
			color 255, 255, 255: pos 0, 0: font fontname, TextSize, Style: print BorderText
		}
		buffer SCR_TEXT_BUF, 1200, TextSize: gsel SCR_TEXT_BUF
		color 0, 0, 0: boxf 0, 0, 1199, TextSize-1
		repeat TextSize
			ColorSlideDividend = (cnt\(TextSize/2))*(cnt\(TextSize/2))
			ColorSlideDivisor = (TextSize/2)*(TextSize/2)
			color BorderTextR-(BorderTextR-GradR)*ColorSlideDividend/ColorSlideDivisor, BorderTextG-(BorderTextG-GradG)*ColorSlideDividend/ColorSlideDivisor, BorderTextB-(BorderTextB-GradB)*ColorSlideDividend/ColorSlideDivisor
			line 599, cnt, 0, cnt
		loop
		if (TextWidthRate == 1.0) {
			color 255, 255, 255: pos 600, 0: font fontname, TextSize, Style: print BorderText
		} else {
			color 255, 255, 255: pos 600, 0
			gzoom int(1200.0*TextWidthRate), TextSize, SCR_TEXT_RESIZE_BUF, 0, 0, 1200, TextSize, 1
		}
		gsel tmpscr: pos BorderTextX, BorderTextY: gmode gmode_pixela, 600, TextSize
		gcopy SCR_TEXT_BUF, 0, 0, 600, TextSize
		gmode gmode_mem
	} else {
		color BorderTextR, BorderTextG, BorderTextB: pos BorderTextX, BorderTextY
		print BorderText
	}
return
#global

/* プレイヤーの自風がどれか調べる */
#module
#include "const.as"
#defcfunc playerwind int player, int currentRound
#ifdef SANMAT
	return ((player+24-(currentRound-(currentRound/4)))\NUM_OF_ACTUAL_PLAYERS)
#else
	return ((player+32-currentRound)\NUM_OF_ACTUAL_PLAYERS)
#endif
#global

/* あるプレイヤーに対して指定したプレイヤーがどこ(下家、対面、上家)にいるか調べる */
#module
#include "const.as"
#defcfunc playerRelative int targetPlayer, int basePlayer
	// ((4+targetPlayer-getPlayer(GameStat))\4)*(TileShowMode) の値
	// 0…自家 1…下家 2…対面 3…上家
	return (NUM_OF_PLAYERS+targetPlayer-basePlayer)\NUM_OF_PLAYERS
#global

/* あるプレイヤーの(下家、対面、上家)を調べる */
#module
#include "const.as"
#defcfunc RelativePositionOf int targetPlayer, int relative
	return (targetPlayer+relative)\NUM_OF_PLAYERS
#global

/* 「東家」「南家」「西家」「北家」の文字列を返す */
#module
#include "const.as"
#defcfunc windName int wind
	switch wind
		case PLAYER_EAST: return "東家": swbreak
		case PLAYER_SOUTH: return "南家": swbreak
		case PLAYER_WEST: return "西家": swbreak
		case PLAYER_NORTH: return "北家": swbreak
		default: return "????": swbreak
	swend
#global

/* 「東○局」などの文字列を返す */
#module
#include "const.as"
#defcfunc roundName int roundNum
	roundNameTxt = ""
	switch roundNum/NUM_OF_PLAYERS
		case 0: roundNameTxt += "東": swbreak
		case 1: roundNameTxt += "南": swbreak
		case 2: roundNameTxt += "西": swbreak
		case 3: roundNameTxt += "北": swbreak
		default: roundNameTxt += "??"
	swend
	if ((getRule(RULE_GAME_LENGTH) == 5)||(getRule(RULE_GAME_LENGTH) == 7)) {
		switch getRoundLoop(GameStat)*NUM_OF_ACTUAL_PLAYERS+roundNum\NUM_OF_PLAYERS
			case 0: roundNameTxt += "一局": swbreak
			case 1: roundNameTxt += "二局": swbreak
			case 2: roundNameTxt += "三局": swbreak
			case 3: roundNameTxt += "四局": swbreak
			case 4: roundNameTxt += "五局": swbreak
			case 5: roundNameTxt += "六局": swbreak
			case 6: roundNameTxt += "七局": swbreak
			case 7: roundNameTxt += "八局": swbreak
			case 8: roundNameTxt += "九局": swbreak
			case 9: roundNameTxt += "十局": swbreak
			default: roundNameTxt += strf("%d局", getRoundLoop(GameStat)*NUM_OF_ACTUAL_PLAYERS+1)
		swend
	} else {
		switch roundNum\NUM_OF_PLAYERS
			case 0: roundNameTxt += "一局": swbreak
			case 1: roundNameTxt += "二局": swbreak
			case 2: roundNameTxt += "三局": swbreak
			case 3: roundNameTxt += "四局": swbreak
			default: roundNameTxt += "??局"
		swend
	}
	return roundNameTxt
#global

/* 牌の名前の文字列を返す */
#module
#include "const.as"
#defcfunc TileName int tile
	switch tile
		case TILE_SUIT_CHARACTERS+1: return "一萬": swbreak
		case TILE_SUIT_CHARACTERS+2: return "二萬": swbreak
		case TILE_SUIT_CHARACTERS+3: return "三萬": swbreak
		case TILE_SUIT_CHARACTERS+4: return "四萬": swbreak
		case TILE_SUIT_CHARACTERS+5: return "五萬": swbreak
		case TILE_SUIT_CHARACTERS+6: return "六萬": swbreak
		case TILE_SUIT_CHARACTERS+7: return "七萬": swbreak
		case TILE_SUIT_CHARACTERS+8: return "八萬": swbreak
		case TILE_SUIT_CHARACTERS+9: return "九萬": swbreak
		case TILE_SUIT_CIRCLES+1: return "一筒": swbreak
		case TILE_SUIT_CIRCLES+2: return "二筒": swbreak
		case TILE_SUIT_CIRCLES+3: return "三筒": swbreak
		case TILE_SUIT_CIRCLES+4: return "四筒": swbreak
		case TILE_SUIT_CIRCLES+5: return "五筒": swbreak
		case TILE_SUIT_CIRCLES+6: return "六筒": swbreak
		case TILE_SUIT_CIRCLES+7: return "七筒": swbreak
		case TILE_SUIT_CIRCLES+8: return "八筒": swbreak
		case TILE_SUIT_CIRCLES+9: return "九筒": swbreak
		case TILE_SUIT_BAMBOOS+1: return "一索": swbreak
		case TILE_SUIT_BAMBOOS+2: return "二索": swbreak
		case TILE_SUIT_BAMBOOS+3: return "三索": swbreak
		case TILE_SUIT_BAMBOOS+4: return "四索": swbreak
		case TILE_SUIT_BAMBOOS+5: return "五索": swbreak
		case TILE_SUIT_BAMBOOS+6: return "六索": swbreak
		case TILE_SUIT_BAMBOOS+7: return "七索": swbreak
		case TILE_SUIT_BAMBOOS+8: return "八索": swbreak
		case TILE_SUIT_BAMBOOS+9: return "九索": swbreak
		case TILE_EAST_WIND   : return "東": swbreak
		case TILE_SOUTH_WIND  : return "南": swbreak
		case TILE_WEST_WIND   : return "西": swbreak
		case TILE_NORTH_WIND  : return "北": swbreak
		case TILE_WHITE_DRAGON: return "白": swbreak
		case TILE_GREEN_DRAGON: return "發": swbreak
		case TILE_RED_DRAGON  : return "中": swbreak
		default: return "????": swbreak
	swend
#global

/* 王牌を除いた山牌の残り枚数 */
#module
#defcfunc tilesLeft var GameStat
	return (getRinshanPointer(GameStat) - (getDeadWallLength(GameStat)-1) - getDrawPointer(GameStat))
#global

/* 順位を計算する */
#module
#include "const.as"
#deffunc calcRank array Rank, var GameStat
	dim Rank, NUM_OF_PLAYERS
	repeat NUM_OF_ACTUAL_PLAYERS
		Rank(cnt) = 1
		tmpcnt = cnt
		repeat NUM_OF_ACTUAL_PLAYERS
			tmpcntt = cnt
			repeat NUM_OF_DIGIT_GROUPS
				if (getScore(GameStat,tmpcntt,NUM_OF_DIGIT_GROUPS-1-cnt) > getScore(GameStat,tmpcnt,NUM_OF_DIGIT_GROUPS-1-cnt)) {Rank(tmpcnt)++: break}
				if (getScore(GameStat,tmpcntt,NUM_OF_DIGIT_GROUPS-1-cnt) < getScore(GameStat,tmpcnt,NUM_OF_DIGIT_GROUPS-1-cnt)) {break}
				if ((cnt == NUM_OF_DIGIT_GROUPS-1)&&(tmpcnt > tmpcntt)) {Rank(tmpcnt)++}
			loop
		loop
	loop
	return
#global

/* 包かどうかの判定 */
#module
#include "const.as"
#defcfunc isPao var GameStat, int agariPlayer, int paoPlayer
	paoFlag = 0
	repeat PAO_YAKU_PAGES
		if ((paoPlayer == getPao(GameStat, PAO_PLAYER_PAO, cnt))&&(getPao(GameStat, PAO_PLAYER_AGARI, cnt) == agariPlayer)) {
			paoFlag = 1
		}
	loop
	return paoFlag
#global

#module
#include "const.as"
#defcfunc isPaoAgari var GameStat, int agariPlayer
	paoFlag = 0
	repeat PAO_YAKU_PAGES
		if (getPao(GameStat, PAO_PLAYER_AGARI, cnt) == agariPlayer) {
			paoFlag = 1
		}
	loop
	return paoFlag
#global

#module
#include "const.as"
#defcfunc isGotPao var GameStat, int paoPlayer
	paoFlag = 0
	repeat PAO_YAKU_PAGES
		if (paoPlayer == getPao(GameStat, PAO_PLAYER_PAO, cnt)) {
			paoFlag = 1
		}
	loop
	return paoFlag
#global

#module
#include "const.as"
#defcfunc getPaoPlayer var GameStat, int agariPlayer
	PaoPlayer = -1
	repeat PAO_YAKU_PAGES
		if ((getPao(GameStat, PAO_PLAYER_PAO, cnt) >= 0)&&(getPao(GameStat, PAO_PLAYER_AGARI, cnt) == agariPlayer)) {
			PaoPlayer = getPao(GameStat, PAO_PLAYER_PAO, cnt)
		}
	loop
	return PaoPlayer
#global

/* Vista/7を使っているかどうか */
#module
#defcfunc isVista
	wver = sysinfo(0)
	/* sysinfo(0)で帰ってくる情報
		XP    … ver5.2
		Vista … ver6.0
		7     … ver6.1
	*/
	if (instr(wver, 0, "WindowsNT ver6") >= 0) {
		return 1
	}
	return 0
#global

/* コンフィグのパスを自動設定 */
/* Vista以降でRoamingに準備できていなければ作る */
#module
#defcfunc confPath
	configpath = ""
	if (isVista()) {
		currentPath = dir_cur
		if (instr(currentPath, 0, dirinfo(0x10026)) >= 0) {
			appdataPath = dirinfo(0x1001a)
			chdir appdataPath
			dirlist dir_roaming,"*",5
			if (notesearch(dir_roaming, "MiHaJong") == -1) {
				mkdir "MiHaJong"
				chdir "MiHaJong"
				mkdir "haifu"
				bcopy currentPath+"\\haifu\\haifu.css", appdataPath+"\\MiHaJong\\haifu\\haifu.css"
			}
			configpath = appdataPath+"\\MiHaJong\\"
			chdir currentPath
		}
	}
	return configpath
#global

/* エラーがあったときに安全に終了させるための処理 */
*errordlg
	error strf("内部エラー [%d] が発生しました。", wparam)
	dialog "内部エラー "+wparam+" が発生しました。", 1
	/* FALLTHRU */

/* 終了処理 */
*cleanup
	gsel SCR_CHAT, -1
	gsel 0, -1
	dmstop: dmend
	info "DirectMusic を解放しました。"
	repeat SND_END-SND_START+1
		dsstop cnt+SND_START
	loop
	repeat VOX_END-VOX_START+1
		dsstop cnt+VOX_START
	loop
	dsend
	info "DirectSound を解放しました。"
	repeat NUM_OF_PLAYERS
		sockclose SOCK_GAME+cnt
		sockclose SOCK_CHAT+cnt
	loop
	sockclose SOCK_LOGGER
	end

#include "IMPORTED.hsp"
