/*=============================
 * HSP麻雀クライアントMiHaJong
 *      [局終了ルーチン]
 *=============================
 */

#module
#include "const.hsp"
#include "mjcore.hsp"
#include "sounddll.hsp"
#deffunc checkroundabort var GameStat, var GameEnv
	/* 四開槓なら流す */
	if (chkRule("four_kong_ryuukyoku", "continue") == 0) {
		if ((getTotalKang(GameStat) == 4)&&(getNumberOfQuads(GameStat, 0) < 4)&&(getNumberOfQuads(GameStat, 1) < 4)&&(getNumberOfQuads(GameStat, 2) < 4)&&(getNumberOfQuads(GameStat, 3) < 4)) {
			RoundEndType = ENDKYOKU_SUUKAIKAN
			redrscreen: return RoundEndType
		}
	}
#ifdef ALLSANMA
	// 三人立直の判定
	if (chkRule("four_riichi_ryuukyoku", "continue") == 0) {
#ifdef SANMA4
		if (((getRichiFlag(GameStat, RICHI_FLAG, 0) != RIICHI_NO)||(playerwind(0, getRound(GameStat)) == PLAYER_NORTH))&&((getRichiFlag(GameStat, RICHI_FLAG, 1) != RIICHI_NO)||(playerwind(1, getRound(GameStat)) == PLAYER_NORTH))&&((getRichiFlag(GameStat, RICHI_FLAG, 2) != RIICHI_NO)||(playerwind(2, getRound(GameStat)) == PLAYER_NORTH))&&((getRichiFlag(GameStat, RICHI_FLAG, 3) != RIICHI_NO)||(playerwind(3, getRound(GameStat)) == PLAYER_NORTH))) {
#else
		if ((getRichiFlag(GameStat, RICHI_FLAG, 0)*getRichiFlag(GameStat, RICHI_FLAG, 1)*getRichiFlag(GameStat, RICHI_FLAG, 2)) != 0) {
#endif
			RoundEndType = ENDKYOKU_SUUCHARIICHI: return RoundEndType
		}
	}
	// 三風連打の判定
	if (chkRule("four_wind_ryuukyoku", "continue") == 0) {
#ifdef SANMA4
		if (((DiscardPointer(GameStat, 0) == 1)||(playerwind(0, getRound(GameStat)) == PLAYER_NORTH))&&((DiscardPointer(GameStat, 1) == 1)||(playerwind(1, getRound(GameStat)) == PLAYER_NORTH))&&((DiscardPointer(GameStat, 2) == 1)||(playerwind(2, getRound(GameStat)) == PLAYER_NORTH))&&((DiscardPointer(GameStat, 3) == 1)||(playerwind(3, getRound(GameStat)) == PLAYER_NORTH))) {
			if (((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) == getDiscard(GameStat, DISCARD_TILECODE, 1, 1))||(playerwind(1, getRound(GameStat)) == PLAYER_NORTH))&&((getDiscard(GameStat, DISCARD_TILECODE, 1, 1) == getDiscard(GameStat, DISCARD_TILECODE, 1, 2))||(playerwind(2, getRound(GameStat)) == PLAYER_NORTH))&&((getDiscard(GameStat, DISCARD_TILECODE, 1, 2) == getDiscard(GameStat, DISCARD_TILECODE, 1, 3))||(playerwind(3, getRound(GameStat)) == PLAYER_NORTH))&&((getDiscard(GameStat, DISCARD_TILECODE, 1, 3) == getDiscard(GameStat, DISCARD_TILECODE, 1, 0))||(playerwind(0, getRound(GameStat)) == PLAYER_NORTH))) {
#else
		if ((DiscardPointer(GameStat, 0) == 1)&&(DiscardPointer(GameStat, 1) == 1)&&(DiscardPointer(GameStat, 2) == 1)) {
			if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) == getDiscard(GameStat, DISCARD_TILECODE, 1, 1))&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 1) == getDiscard(GameStat, DISCARD_TILECODE, 1, 2))) {
#endif
				if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) >= TILE_WIND_MIN)&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 0) <= TILE_WIND_MAX)) {
					RoundEndType = ENDKYOKU_SUUFONRENDA: return RoundEndType
				}
			}
		}
	}
#else
	// 四人立直の判定
	if (((getRichiFlag(GameStat, RICHI_FLAG, 0)*getRichiFlag(GameStat, RICHI_FLAG, 1)*getRichiFlag(GameStat, RICHI_FLAG, 2)*getRichiFlag(GameStat, RICHI_FLAG, 3)) != 0)&&(chkRule("four_riichi_ryuukyoku", "continue") == 0)) {
		RoundEndType = ENDKYOKU_SUUCHARIICHI: return RoundEndType
	}
	// 四風連打の判定
	if (chkRule("four_wind_ryuukyoku", "continue") == 0) {
		if ((DiscardPointer(GameStat, 0) == 1)&&(DiscardPointer(GameStat, 1) == 1)&&(DiscardPointer(GameStat, 2) == 1)&&(DiscardPointer(GameStat, 3) == 1)) {
			if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) == getDiscard(GameStat, DISCARD_TILECODE, 1, 1))&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 1) == getDiscard(GameStat, DISCARD_TILECODE, 1, 2))&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 2) == getDiscard(GameStat, DISCARD_TILECODE, 1, 3))) {
				if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) >= TILE_WIND_MIN)&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 0) <= TILE_WIND_MAX)) {
					RoundEndType = ENDKYOKU_SUUFONRENDA: return RoundEndType
				}
			}
		}
	}
#endif
	repeat NUM_OF_PLAYERS: setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, cnt, 0: loop // バグ防止のため
	if (((getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE) == getPreviousMeld(GameStat, PREVMELD_TILECODE))||(getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE) == getPreviousMeld(GameStat, PREVMELD_STEPPED)))&&(getAgariHouki(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0)) {
		// 喰い替えの場合の処理
		if (chkRule("kuikae", "agari_houki") || chkRule("kuikae", "agari_houki_if_in_kind")) {
			/* 和了り放棄とする設定 */
			info strf("喰い変えを検出しました。和了り放棄として扱います。打牌 [%d] 鳴いた牌 [%d]", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), getPreviousMeld(GameStat, PREVMELD_TILECODE))
			snd_play SND_CUOHU
			repeat 2
				setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "喰替"
				redrscreen: await 1500
				setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "和了放棄"
				redrscreen: await 1500
			loop
			setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), ""
			redrscreen
			/* 和了り放棄は以降強制ツモ切り、強制不聴扱いとなります */
			setAgariHouki GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 1
			if (GetWatchModeFlag(GameEnv) == 0) {statmes "和了り放棄：強制ツモ切りされます"}
			vanish2@
		} else: if (chkRule("kuikae", "chombo") || chkRule("kuikae", "chombo_if_in_kind")) {
			/* 直ちに錯和とする設定 */
			info strf("喰い変えを検出しました。チョンボとして扱います。打牌 [%d] 鳴いた牌 [%d]", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), getPreviousMeld(GameStat, PREVMELD_TILECODE))
			snd_play SND_CUOHU
			RoundEndType = ENDKYOKU_CHONBO: setTsumoAgariFlag GameStat, AGARI_KUIKAE
			setCurrentPlayer GameStat, CURRENTPLAYER_AGARI, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
			setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "錯和"
			redrscreen: await 1500
			/* 局を打ち切り、満貫罰符の支払いに進む */
			return RoundEndType
		}
	}
	/* 多牌や少牌をしていないかのチェック */
	tmptilecnt = 0
	repeat NUM_OF_TILES_IN_HAND
		if (getHand(GameStat, HAND_TILECODE, cnt, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) > 0) {tmptilecnt++}
	loop
	tmptilecnt += (MeldPointer(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) * 3)
	if ((tmptilecnt != (NUM_OF_TILES_IN_HAND-1))&&(getAgariHouki(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0)) {
//			多牌や少牌の場合の処理(通常起きることはないはずだが…)
		if (tmptilecnt > (NUM_OF_TILES_IN_HAND-1)) {
			warn "多牌を検出しました。和了り放棄として扱いますが、摸打の処理で不整合が起きていた可能性があります。"
		} else {
			warn "少牌を検出しました。和了り放棄として扱いますが、摸打の処理で不整合が起きていた可能性があります。"
		}
		snd_play SND_CUOHU
		repeat 2
			if (tmptilecnt > (NUM_OF_TILES_IN_HAND-1)) {
				setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "多牌"
			} else {
				setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "少牌"
			}
			redrscreen: await 1500
			setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "和了放棄"
			redrscreen: await 1500
		loop
		setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), ""
		redrscreen
		setAgariHouki GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 1
		if (GetWatchModeFlag(GameEnv) == 0) {statmes "和了り放棄：強制ツモ切りされます"}
		vanish2@
	}
	await 0
	/* 荒牌の場合ここで終了する(河底牌は吃ポンできないがロンはできる) */
	if (getDrawPointer(GameStat) == (getRinshanPointer(GameStat) - (getDeadWallLength(GameStat)-1))) {RoundEndType = ENDKYOKU_RYUUKYOKU: return RoundEndType}
	return -1
#global

#module
#include "const.hsp"
#include "mjcore.hsp"
#include "sounddll.hsp"
#deffunc endround var GameStat, var GameEnv, int _RoundEndType, int OrigTurn, int OrigHonba
	// 局面終了コード
	// ０…荒牌流局
	// １…誰かの和了り
	// ２…誰かのチョンボ
	// ３…九種九牌流れ
	// ４…四槓流れ
	// ５…三家和流れ
	// ６…四風流れ
	// ７…四人立直流れ
	// ８…流し満貫
	// ９…回線切断
	// 10…５回目の槓で流れた場合
	RoundEndType = _RoundEndType
	info strf("局を終了 終了コード [%d]", RoundEndType)
	statmes ""
	vanish2@
	if (RoundEndType == ENDKYOKU_RYUUKYOKU) {
		dim NagashiManganFlag, NUM_OF_PLAYERS
		repeat NUM_OF_ACTUAL_PLAYERS
#ifdef SANMA4
			if (playerWind(cnt, getRound(GameStat)) == PLAYER_NORTH) {
				continue // 北家は無視
			}
#endif
			if (chkRule("nagashi_mangan", "no") == 0) {
				if (isNagashiMangan(GameStat, GameEnv, cnt)) {NagashiManganFlag(cnt) = 1: RoundEndType = ENDKYOKU_NAGASHIMANGAN}
			}
		loop
	}
	/************/
	/* 和了処理 */
	/************/
	if ((RoundEndType == ENDKYOKU_AGARI)||(RoundEndType == ENDKYOKU_CHONBO)) {
		agariproc RoundEndType, GameStat, GameEnv, tmpUraFlag, tmpAliceFlag, ResultDesc
	}
	switch RoundEndType
	/**************/
	/* 荒牌流局時 */
	/**************/
		case ENDKYOKU_RYUUKYOKU:
			statmes "流局です"
			ResultDesc = "荒牌流局"
			chatappend "*** "+ResultDesc+"\n"
			setCenterTitle "流局"
			bgmplay MUS_RYUUKYOKU
			snd_play SND_PINGJU
			redrscreen: await 1500
			TenpaiCnt = 0
			repeat NUM_OF_PLAYERS
#ifdef SANMA4
				if (playerWind(cnt, getRound(GameStat)) == PLAYER_NORTH) {
					continue // 北家は無視
				}
#endif
				if (isTenpai(GameStat, GameEnv, cnt)) {
					TenpaiCnt++
					setHandStat GameStat, cnt, 1
					setCall cnt, "聴牌"
				} else:if (getRichiFlag(GameStat, RICHI_FLAG, cnt)) {
					setHandStat GameStat, cnt, 1
					setCall cnt, "錯和"
				} else {
					setHandStat GameStat, cnt, 2
					setCall cnt, "不聴"
				}
			loop
			switch TenpaiCnt
				case 0: TenpaiCountTxt = "全員不聴": swbreak
				case 1: TenpaiCountTxt = "１人聴牌": swbreak
				case 2: TenpaiCountTxt = "２人聴牌": swbreak
				case 3: TenpaiCountTxt = "３人聴牌": swbreak
				case 4: TenpaiCountTxt = "４人聴牌": swbreak
			swend
			ResultDesc = "荒牌流局、"+TenpaiCountTxt
			statmes "流局 "+TenpaiCountTxt
			chatappend "*** "+TenpaiCountTxt+"です\n"
			setCenterTitle TenpaiCountTxt
//			title "流局"
			redrscreen: await 5000
			dim PointDelta, NUM_OF_PLAYERS, NUM_OF_DIGIT_GROUPS
			repeat NUM_OF_ACTUAL_PLAYERS
#ifdef SANMA4
				if (playerWind(cnt, getRound(GameStat)) == PLAYER_NORTH) {
					continue // 北家は無視
				}
#endif
#ifdef ALLSANMA
				if (isTenpai(GameStat, GameEnv, cnt)) {
					if (TenpaiCnt == 1) {PointDelta(cnt) += 30}
					if (TenpaiCnt == 2) {PointDelta(cnt) += 15}
				} else {
					if (TenpaiCnt == 1) {PointDelta(cnt) -= 15}
					if (TenpaiCnt == 2) {PointDelta(cnt) -= 30}
				}
#else
				if (isTenpai(GameStat, GameEnv, cnt)) {
					if (TenpaiCnt == 1) {PointDelta(cnt) += 30}
					if (TenpaiCnt == 2) {PointDelta(cnt) += 15}
					if (TenpaiCnt == 3) {PointDelta(cnt) += 10}
				} else {
					if (TenpaiCnt == 1) {PointDelta(cnt) -= 10}
					if (TenpaiCnt == 2) {PointDelta(cnt) -= 15}
					if (TenpaiCnt == 3) {PointDelta(cnt) -= 30}
				}
#endif
			loop
			if ((TenpaiCnt > 0)&&(TenpaiCnt < NUM_OF_ACTUAL_PLAYERS)) {
				setCenterTitle "不聴罰符"
				putdelta PointDelta
				redraw 1: await 2500
				pointcalc GameStat, PointDelta
			}
			
			repeat NUM_OF_ACTUAL_PLAYERS
				// 錯和立直（不聴立直）の者がいた場合
				if ((isTenpai(GameStat, GameEnv, cnt) == 0)&&(getRichiFlag(GameStat, RICHI_FLAG, cnt))) {
					transferChonboPenalty GameStat, cnt
					await 500
				}
			loop
			
			RenchanFlag = 0
			if (chkRule("round_continuation", "renchan_if_ready")) {
				if (isTenpai(GameStat, GameEnv, (getRound(GameStat)\NUM_OF_PLAYERS))) {RenchanFlag = 1}
			} else: if (chkRule("round_continuation", "renchan_always")) {
				RenchanFlag = 1
			} else: if (chkRule("round_continuation", "renchan_if_ready_until_final_round")) {
				if ((isTenpai(GameStat, GameEnv, (getRound(GameStat)\NUM_OF_PLAYERS)))||((getGameLength(GameStat)/NUM_OF_ACTUAL_PLAYERS) <= (getRoundLoop(GameStat)*roundLoopRate()+getRound(GameStat))/NUM_OF_ACTUAL_PLAYERS)) {RenchanFlag = 1}
			} else: if (chkRule("round_continuation", "renchan_if_mahjong_until_final_round")) {
				if ((isTenpai(GameStat, GameEnv, (getRound(GameStat)\NUM_OF_PLAYERS)))&&((getGameLength(GameStat)/NUM_OF_ACTUAL_PLAYERS) <= (getRoundLoop(GameStat)*roundLoopRate()+getRound(GameStat))/NUM_OF_ACTUAL_PLAYERS)) {RenchanFlag = 1}
			}
			ryuukyokuProc GameStat, RenchanFlag
		swbreak
	/**************/
	/* 和了成立時 */
	/**************/
		case ENDKYOKU_AGARI:
			repeat NUM_OF_PLAYERS
				setCall cnt, ""
			loop
			setCenterTitle ""
			if ((playerwind(getCurrentPlayer(GameStat, CURRENTPLAYER_AGARI), getRound(GameStat)) == PLAYER_EAST)&&(chkRule("round_continuation", "renchan_never") == 0)) {
				setCall getRound(GameStat)\NUM_OF_PLAYERS, "連荘"
			} else {
				setCall getRound(GameStat)\NUM_OF_PLAYERS, "親流れ"
			}
			snd_play SND_PAGE
			redrscreen
			redraw 1
			
			if ((playerwind(getCurrentPlayer(GameStat, CURRENTPLAYER_AGARI), getRound(GameStat)) == PLAYER_EAST)&&(chkRule("round_continuation", "renchan_never") == 0)) {
				incHonba GameStat
			} else {
				setHonba GameStat, 0: incRound GameStat
			}
			setDeposit GameStat, 0
			// 八連荘成立時、カウンタをリセット
			if (getAgariChain(GameStat) == 8) {
				setAgariChain GameStat, 0
			}
		swbreak
	/**************/
	/* 錯和発生時 */
	/**************/
		case ENDKYOKU_CHONBO:
			setAgariChain GameStat, 0: setLastAgariPlayer GameStat, -1
		swbreak
	/**************/
	/* 九種流局時 */
	/**************/
#ifndef SANMAS
		case ENDKYOKU_KYUUSHUKYUUHAI:
			statmes "流局(九種九牌)"
			switch playerWind(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getRound(GameStat))
				case PLAYER_EAST: ResultDesc = "東家の九種九牌": swbreak
				case PLAYER_SOUTH: ResultDesc = "南家の九種九牌": swbreak
				case PLAYER_WEST: ResultDesc = "西家の九種九牌": swbreak
				case PLAYER_NORTH: ResultDesc = "北家の九種九牌": swbreak
			swend
			chatappend "*** "+ResultDesc+"\n"
			await 1500
			setCenterTitle "流局"
			snd_play SND_PINGJU
			bgmplay MUS_RYUUKYOKU
			redrscreen: redraw 1: await 3000
			if (chkRule("nine_terminals", "next_dealer") == 0) {
				if ((chkRule("nine_terminals", "renchan_if_dealer_kyuushu") == 0)||(playerWind(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getRound(GameStat)) == PLAYER_EAST)) {
					RenchanFlag = 1
				} else {
					RenchanFlag = 0
				}
			} else {
				RenchanFlag = 0
			}
			ryuukyokuProc GameStat, RenchanFlag
		swbreak
#endif
	/**************/
	/* 四槓流局時 */
	/**************/
		case ENDKYOKU_SUUKAIKAN:
			statmes "流局(四開槓)"
			snd_play VOX_SIKANG
			ResultDesc = "四開槓"
			chatappend "*** "+ResultDesc+"\n"
			setCenterTitle "四開槓"
			redrscreen: redraw 1: await 3000
			repeat NUM_OF_PLAYERS
				setCall cnt, ""
			loop
			snd_play SND_PINGJU
			bgmplay MUS_RYUUKYOKU
			setCenterTitle "流局"
			redrscreen: redraw 1: await 3000
			ryuukyokuProc GameStat, (chkRule("four_kong_ryuukyoku", "next_dealer") == 0)
		swbreak
	/**************/
	/* 三家和の時 */
	/**************/
		case ENDKYOKU_TRIPLERON:
#ifdef ALLSANMA
			statmes "流局(二家和)"
			await 1300
			snd_play VOX_SANJIAHU
			ResultDesc = "二家和"
			chatappend "*** "+ResultDesc+"\n"
			setCenterTitle "二家和"
#else
			statmes "流局(三家和)"
			await 1300
			snd_play VOX_SANJIAHU
			ResultDesc = "三家和"
			chatappend "*** "+ResultDesc+"\n"
			setCenterTitle "三家和"
#endif
			redrscreen: redraw 1: await 3000
			repeat NUM_OF_PLAYERS
				setCall cnt, ""
			loop
			snd_play SND_PINGJU
			bgmplay MUS_RYUUKYOKU
			setCenterTitle "流局"
			redrscreen: redraw 1: await 3000

			if (chkRule("triple_mahjong", "renchan_if_nondealer_furikomi")) {
				if (playerWind(getCurrentPlayer(GameStat, CURRENTPLAYER_FURIKOMI), getRound(GameStat)) != PLAYER_EAST) {
					RenchanFlag = 1
				} else {
					RenchanFlag = 0
				}
			} else: if (chkRule("triple_mahjong", "renchan_if_north_furikomi") || chkRule("triple_mahjong", "renchan_if_west_furikomi")) {
				if (playerWind(getCurrentPlayer(GameStat, CURRENTPLAYER_FURIKOMI), getRound(GameStat)) == PLAYER_NORTH) {
					RenchanFlag = 1
				} else {
					RenchanFlag = 0
				}
			} else: if (chkRule("triple_mahjong", "same_dealer")) {
				RenchanFlag = 1
			} else: if (chkRule("triple_mahjong", "next_dealer")) {
				RenchanFlag = 0
			}
			ryuukyokuProc GameStat, RenchanFlag
		swbreak
	/**************/
	/* 四風流局時 */
	/**************/
		case ENDKYOKU_SUUFONRENDA:
#ifdef ALLSANMA
			statmes "流局(三風連打)"
			snd_play VOX_SIFENG
			ResultDesc = "三風連打"
			chatappend "*** "+ResultDesc+"\n"
			setCenterTitle "三風連打"
#else
			statmes "流局(四風連打)"
			snd_play VOX_SIFENG
			ResultDesc = "四風連打"
			chatappend "*** "+ResultDesc+"\n"
			setCenterTitle "四風連打"
#endif
			redrscreen: redraw 1: await 3000
			repeat NUM_OF_PLAYERS
				setCall cnt, ""
			loop
			snd_play SND_PINGJU
			bgmplay MUS_RYUUKYOKU
			setCenterTitle "流局"
			redrscreen: redraw 1: await 3000
			ryuukyokuProc GameStat, (chkRule("four_wind_ryuukyoku", "next_dealer") == 0)
		swbreak
	/**************/
	/* 四人立直時 */
	/**************/
		case ENDKYOKU_SUUCHARIICHI:
#ifdef ALLSANMA
			statmes "流局(三家立直)"
			snd_play VOX_SIJIARICHI
			ResultDesc = "三家立直"
			chatappend "*** "+ResultDesc+"\n"
			setCenterTitle "三家立直"
#else
			statmes "流局(四家立直)"
			snd_play VOX_SIJIARICHI
			ResultDesc = "四家立直"
			chatappend "*** "+ResultDesc+"\n"
			setCenterTitle "四家立直"
#endif
			redrscreen: redraw 1: await 3000
			repeat NUM_OF_PLAYERS
				setCall cnt, ""
			loop
			snd_play SND_PINGJU
			bgmplay MUS_RYUUKYOKU
			setCenterTitle "流局"
			redrscreen: redraw 1: await 1500
			TenpaiCnt = 0
			repeat NUM_OF_PLAYERS
#ifdef SANMA4
				if (playerWind(targetPlayer, getRound(GameStat)) == PLAYER_NORTH) {continue}
#endif
				setHandStat GameStat, cnt, 1
				if (isTenpai(GameStat, GameEnv, cnt)) {
					setCall cnt, "聴牌"
				} else {
					setCall cnt, "錯和"
				}
			loop
			redrscreen: await 5000

			repeat NUM_OF_ACTUAL_PLAYERS
#ifdef SANMA4
				if (playerWind(targetPlayer, getRound(GameStat)) == PLAYER_NORTH) {continue}
#endif
				// 錯和立直（不聴立直）の者がいた場合
				if (isTenpai(GameStat, GameEnv, cnt) == 0) {
					transferChonboPenalty GameStat, cnt
					await 500
				}
			loop

			ryuukyokuProc GameStat, (chkRule("four_riichi_ryuukyoku", "next_dealer") == 0)
		swbreak
	/**************/
	/* 流し満貫時 */
	/**************/
		case ENDKYOKU_NAGASHIMANGAN:
			statmes "流局です"
			snd_play SND_PINGJU
			setCenterTitle "流局"
			if (NagashiManganFlag(getPlayer(GameStat)) == 1) {agariBgmSet = 0} else {agariBgmSet = 1}
			if (GetWatchModeFlag(GameEnv) == 1) {agariBgmSet = 0}
			if (chkRule("nagashi_mangan", "yakuman")) {
				switch agariBgmSet
					case 0: bgmplay MUS_AGARI_SELF_3: swbreak
					case 1: bgmplay MUS_AGARI_FURIKOMI_3: swbreak
				swend
			} else {
				switch agariBgmSet
					case 0: bgmplay MUS_AGARI_SELF_2: swbreak
					case 1: bgmplay MUS_AGARI_FURIKOMI_2: swbreak
				swend
			}
			redrscreen: await 1500
			statmes "流し満貫が成立しました"
			dim PointDelta, NUM_OF_PLAYERS, NUM_OF_DIGIT_GROUPS
			ResultDesc = ""
			repeat NUM_OF_ACTUAL_PLAYERS
				if (isNagashiMangan(GameStat, GameEnv, cnt)) {
					setCall cnt, "流し満貫"
					switch playerWind(cnt, getRound(GameStat))
						case PLAYER_EAST:
							if (ResultDesc != "") {ResultDesc += "、"}
							ResultDesc += "東家"
						swbreak
						case PLAYER_SOUTH:
							if (ResultDesc != "") {ResultDesc += "、"}
							ResultDesc += "南家"
						swbreak
						case PLAYER_WEST:
							if (ResultDesc != "") {ResultDesc += "、"}
							ResultDesc += "西家"
						swbreak
#ifndef SANMAT
						case PLAYER_NORTH:
							if (ResultDesc != "") {ResultDesc += "、"}
							ResultDesc += "北家"
						swbreak
#endif
					swend
					dim AgariPointRaw, NUM_OF_DIGIT_GROUPS
					if (chkRule("nagashi_mangan", "mangan")) {
						AgariPointRaw(0) = 2000
					} else: if (chkRule("nagashi_mangan", "haneman")) {
						AgariPointRaw(0) = 3000
					} else: if (chkRule("nagashi_mangan", "baiman")) {
						AgariPointRaw(0) = 4000
					} else: if (chkRule("nagashi_mangan", "yakuman")) {
						AgariPointRaw(0) = 8000
					}
					calcAgariPoints GameStat, agariPointArray, AgariPointRaw, PointDelta, cnt
				}
			loop
			ResultDesc += "の流し満貫"
			chatappend "*** "+ResultDesc+"\n"
			snd_play SND_PAGE
			redrscreen
			redraw 1: await 1500
			
			setCenterTitle "流し満貫"
			putdelta PointDelta
			redraw 1: await 1500
			pointcalc GameStat, PointDelta
			
			ryuukyokuProc GameStat, 1
		swbreak
	/**************/
	/* 四槓流局時 */
	/**************/
		case ENDKYOKU_UUKAIKAN:
			statmes "流局(四開槓)"
			snd_play VOX_SIKANG
			ResultDesc = "四開槓(５回目の槓での流局)"
			chatappend "*** "+ResultDesc+"\n"
			setCenterTitle "四開槓"
			redrscreen: redraw 1: await 3000
			repeat NUM_OF_PLAYERS
				setCall cnt, ""
			loop
			snd_play SND_PINGJU
			bgmplay MUS_RYUUKYOKU
			setCenterTitle "流局"
			redrscreen: redraw 1: await 3000
			ryuukyokuProc GameStat, (chkRule("fifth_kong", "next_dealer") == 0)
		swbreak
	swend
	haifuwritebuffer GameStat, GameEnv, OrigTurn, OrigHonba, tmpUraFlag, tmpAliceFlag, ResultDesc, RoundEndType
	return
#global

#module
#include "const.hsp"
#include "mjcore.hsp"
#include "sounddll.hsp"
#deffunc ryuukyokuProc var GameStat, int RenchanFlag
	repeat NUM_OF_PLAYERS
		setCall cnt, ""
	loop
	setCenterTitle ""
	if (RenchanFlag) {
		setCall getRound(GameStat)\NUM_OF_PLAYERS, "連荘"
	} else {
		setCall getRound(GameStat)\NUM_OF_PLAYERS, "親流れ"
	}
	snd_play SND_PAGE
	redrscreen
	redraw 1
	incHonba GameStat
	if (RenchanFlag): else {
		incRound GameStat
	}
	setAgariChain GameStat, 0: setLastAgariPlayer GameStat, -1
	return
#global

#module
#include "const.hsp"
#include "mjcore.hsp"
#deffunc transferChonboPenalty var GameStat, int targetPlayer
	dim PointDelta, NUM_OF_PLAYERS, NUM_OF_DIGIT_GROUPS
	dim AgariPointRaw, NUM_OF_DIGIT_GROUPS
	AgariPointRaw(0) = 2000
	calcAgariPoints GameStat, agariPointArray, AgariPointRaw, PointDelta, targetPlayer
	repeat NUM_OF_PLAYERS*NUM_OF_DIGIT_GROUPS
		PointDelta(cnt\NUM_OF_PLAYERS, cnt/NUM_OF_PLAYERS) = -PointDelta(cnt\NUM_OF_PLAYERS, cnt/NUM_OF_PLAYERS)
	loop
	/* なぜわざわざ一旦プラスで求めて符号を反転するという回りくどいことをしているのかというと
	   点パネの計算時に天井函数(数値として大きい方に丸める)的な処理を行っているため、
	   引数をマイナスで与えると(特に三麻で丸取り設定にしてるときとか)チョンボ料が減る虞があるからです */
	setCenterTitle "錯和罰符"
	putdelta PointDelta
	redraw 1: await 1500
	pointcalc GameStat, PointDelta
	return
#global

#module
#include "const.hsp"
#include "mjcore.hsp"
#deffunc nextRound var GameStat, int OrigTurn
	// ハコ割れ終了
	if (chkRule("buttobi_border", "no") == 0) {
		if (isDobon(GameStat,PLAYER_EAST)) {return 1}
		if (isDobon(GameStat,PLAYER_SOUTH)) {return 1}
		if (isDobon(GameStat,PLAYER_WEST)) {return 1}
#ifndef SANMAT
		if (isDobon(GameStat,PLAYER_NORTH)) {return 1}
#endif
	}
	// 天辺終了
	if (chkRule("teppen", "no") == 0) {
		if (isTeppen(GameStat,PLAYER_EAST)) {return 1}
		if (isTeppen(GameStat,PLAYER_SOUTH)) {return 1}
		if (isTeppen(GameStat,PLAYER_WEST)) {return 1}
#ifndef SANMAT
		if (isTeppen(GameStat,PLAYER_NORTH)) {return 1}
#endif
	}
	// 和了り止め
	if (chkRule("agariyame", "no") == 0) {
		if (((getRound(GameStat)+(getRoundLoop(GameStat)*roundLoopRate())) == getGameLength(GameStat))&&((OrigTurn+(getRoundLoop(GameStat)*roundLoopRate())) == getGameLength(GameStat))&&((RoundEndType == ENDKYOKU_AGARI)||(chkRule("agariyame", "yes_also_ready") != 0))) {
			calcRank Rank, GameStat
			if ((Rank(getRound(GameStat)\NUM_OF_PLAYERS) == 1)&&(getScore(GameStat,getRound(GameStat)\NUM_OF_PLAYERS) >= BasePoint())) {return 1}
		}
	}
#ifdef SANMAT
	if (getRound(GameStat)\NUM_OF_PLAYERS == 3) {incRound GameStat}
#endif
	// 東北廻しのとき
	if ((getRound(GameStat) == 4)&&(chkRule("game_length", "east_north_game") != 0)) {setRound GameStat, 12}
	// 東西廻しのとき
	if ((getRound(GameStat) == 4)&&(chkRule("game_length", "east_west_game") != 0)) {setRound GameStat, 8}
	// 東々廻しのとき
	if ((getRound(GameStat) == 4)&&((chkRule("game_length", "twice_east_game") != 0)||(chkRule("game_length", "east_only_game") != 0))) {setRound GameStat, 16}
	// 通常の半荘終了時（トップが３００００点未満だと西入サドンデス）
	if (((getRound(GameStat)+(getRoundLoop(GameStat)*roundLoopRate())) >= (getGameLength(GameStat)+1))) {
#ifdef SANMAT
		if (((getScore(GameStat,0) >= BasePoint())||(getScore(GameStat,1) >= BasePoint())||(getScore(GameStat,2) >= BasePoint()))) {return 1}
#else
		if (((getScore(GameStat,0) >= BasePoint())||(getScore(GameStat,1) >= BasePoint())||(getScore(GameStat,2) >= BasePoint())||(getScore(GameStat,3) >= BasePoint()))) {return 1}
#endif
		// 延長戦なし設定
		if (chkRule("sudden_death_type", "no")) {return 1}
	}
	// 延長戦の長さに制限がある場合
	if (chkRule("sudden_death_type", "one_extra_round")) {
		if ((getRound(GameStat) == 4)&&((chkRule("game_length", "twice_east_game") != 0)||(chkRule("game_length", "east_only_game") != 0))) {
			// 東々廻しのとき
			if (((getRound(GameStat)+(getRoundLoop(GameStat)*roundLoopRate())) >= (getGameLength(GameStat)+roundLoopRate()))) {
				return 1
			}
		} else {
			// それ以外のとき
			if (((getRound(GameStat)+(getRoundLoop(GameStat)*roundLoopRate())) >= (getGameLength(GameStat)+5))) {
				return 1
			}
		}
	}
	// 北場終了の場合は帰り東へ
	if (getRound(GameStat) == roundLoopRate()) {
		if (chkRule("sudden_death_type", "no")) {
			// 延長戦無しで終了
			return 1
		} else {
			// 返り東
			incRoundLoop GameStat: setRound GameStat, 0
		}
	}
	// 焼き鳥復活ルールの場合
	if ((chkRule("yakitori", "no") == 0) && (chkRule("yakitori_again", "no") == 0)) {
#ifdef SANMAT
		if ((getYakitori(GameStat, 0)+getYakitori(GameStat, 1)+getYakitori(GameStat, 2)) == 0) {
			repeat 3
#else
		if ((getYakitori(GameStat, 0)+getYakitori(GameStat, 1)+getYakitori(GameStat, 2)+getYakitori(GameStat, 3)) == 0) {
			repeat 4
#endif
				setYakitori GameStat, cnt, 1
			loop
		}
	}
	return 0
#global
