/*=============================
 * HSP麻雀クライアントMiHaJong
 *     [牌周りの色々計算]
 *=============================
 */

/* 手牌のうちある１枚に注目する */
#module
#include "const.hsp"
#include "mjcore.hsp"
#defcfunc getpaiinfo var GameStat, int targetPlayer, int targetTile, int CheckMode
/*
		val=getpaiinfo(p1, p2, p3, p4)
		手牌のうち1枚に注目した情報を取得する

		p1 : 卓の状況を格納した構造体
		p2 : 調べるプレイヤー
		p3 : 調べる牌の番号
		p4 : モード

		特定のプレイヤーの手牌のうち1枚を調べます。
*/
	countTilesInHand TileCount, GameStat, targetPlayer
	TileInfo = 0
	if (getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) == 0) {TileInfo = -999: return -999}
	// 暗槓が可能な牌
	if (TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)) == 4) {TileInfo |= 64}
	// 暗刻を形成している場合
	if (TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)) >= 3) {TileInfo |= 1}
	// 順子を形成している場合
	if (getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) < TILE_NUMERAL_MAX) {
		if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)) >= 1)&&(TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)+1) >= 1)&&(TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)+2) >= 1)) {TileInfo |= 2}
		else:if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)-1) >= 1)&&(TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)) >= 1)&&(TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)+1) >= 1)) {TileInfo |= 2}
		else:if (getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) > 1) {
			if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)-2) >= 1)&&(TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)-1) >= 1)&&(TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)) >= 1)) {TileInfo |= 2}
		}
	}
	// 対子を形成している場合
	if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)) >= 2)&&(TileInfo\2 == 0)) {TileInfo |= 4}
	// 辺張を形成している場合
	if (getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) < TILE_NUMERAL_MAX) {
		if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)) >= 1)&&((TileInfo \ 4 < 2)||(CheckMode == 1))) {
			if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)+1) >= 1)&&(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) \ TILE_SUIT_STEP = 1)) {TileInfo |= 8}
			else:if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)+1) >= 1)&&(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) \ TILE_SUIT_STEP = 8)) {TileInfo |= 8}
			else:if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)-1) >= 1)&&(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) \ TILE_SUIT_STEP = 2)) {TileInfo |= 8}
			else:if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)-1) >= 1)&&(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) \ TILE_SUIT_STEP = 9)) {TileInfo |= 8}
		}
	}
	// 両面塔子を形成している場合
	if (getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) < TILE_NUMERAL_MAX) {
		if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)) >= 1)&&((TileInfo \ 4 < 2)||(CheckMode == 1))) {
			if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)+1) >= 1)&&(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) \ TILE_SUIT_STEP != 1)&&(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) \ TILE_SUIT_STEP != 8)) {TileInfo |= 16}
			else: if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)-1) >= 1)&&(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) \ TILE_SUIT_STEP != 2)&&(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) \ TILE_SUIT_STEP != 9)) {TileInfo |= 16}
		}
	}
	// 嵌張を形成している場合
	if (getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) < TILE_NUMERAL_MAX) {
		if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)) >= 1)&&((TileInfo \ 4 < 2)||(CheckMode == 1))) {
			if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)+2) >= 1)&&(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) \ TILE_SUIT_STEP != 9)) {TileInfo |= 32}
			else: if (getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) > 1) {
				if ((TileCount(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer)-2) >= 1)&&(getHand(GameStat, HAND_TILECODE, targetTile, targetPlayer) \ TILE_SUIT_STEP != 1)) {TileInfo |= 32}
			}
		}
	}
return TileInfo
#global

/* 九種九牌流しが可能かどうかのチェック */
#module
#include "const.hsp"
#include "mjcore.hsp"
#defcfunc chkdaopaiability var GameStat, int targetPlayer
	DaoPaiAbilityFlag = 0
	countTilesInHand TileCount, GameStat, targetPlayer
	YaojiuPai = TILE_CHARACTER_ONE, TILE_CHARACTER_NINE, TILE_CIRCLE_ONE, TILE_CIRCLE_NINE, TILE_BAMBOO_ONE, TILE_BAMBOO_NINE
	YaojiuPai(6) = TILE_EAST_WIND, TILE_SOUTH_WIND, TILE_WEST_WIND, TILE_NORTH_WIND, TILE_WHITE_DRAGON, TILE_GREEN_DRAGON, TILE_RED_DRAGON
	YaojiuCount = 0: AtamaFlag = 0
	repeat 13
		// ヤオ九牌１種類につき、１をカウントする。
		if (TileCount(YaojiuPai(cnt)) >= 1) {
			YaojiuCount++
		}
	loop
	if (YaojiuCount >= 9) {DaoPaiAbilityFlag = 1}
return DaoPaiAbilityFlag
#global

/* ドラを設定する */
#module
#include "const.hsp"
#include "mjcore.hsp"
#deffunc setdora var GameStat, int Mode
	debug strf("ドラの追加 ポインタ [%d] 牌コード [%d] モード [%d]", getDoraPointer(GameStat), getWall(GameStat, WALL_TILECODE, getDoraPointer(GameStat)+Mode), Mode)
	if (getWall(GameStat, WALL_TILECODE, getDoraPointer(GameStat)+Mode) > TILE_SUIT_FLOWERS) {
		tmpDora = getWall(GameStat, WALL_TILECODE, getDoraPointer(GameStat)+Mode)
		incDoraFlag GameStat, Mode, TILE_DORA_FLOWER	// 花牌がドラ表示牌になったとき
		debug "花牌をドラにしました。"
		if (Mode) {haifurecuradora tmpdora} else {haifurecdora tmpdora}	// 残りの花牌をダブドラとする
	} else {
		if (getRule(RULE_NAGATACHO) != 0) {
			// 永田町ルール用
			tmpDora = getWall(GameStat, WALL_TILECODE, getDoraPointer(GameStat)+Mode)+1
	#ifdef SANMAX
			if (tmpDora == TILE_CHARACTER_TWO) {tmpDora == TILE_CHARACTER_NINE}
	#endif
			if (tmpDora == TILE_SUIT_CHARACTERS+10) {tmpDora == TILE_CHARACTER_ONE}
			if (tmpDora == TILE_SUIT_CIRCLES+10) {tmpDora == TILE_CIRCLE_ONE}
			if (tmpDora == TILE_SUIT_BAMBOOS+10) {tmpDora == TILE_BAMBOO_ONE}
			if (tmpDora == TILE_WIND_MAX+1) {tmpDora == TILE_WIND_MIN}
			if (tmpDora == TILE_DRAGON_MAX+1) {tmpDora == TILE_DRAGON_MIN}
			if (tmpDora > TILE_NUMERAL_MAX) {
				incDoraFlag GameStat, Mode, tmpDora // ドラを設定する
				if (Mode) {haifurecuradora tmpdora} else {haifurecdora tmpdora}
				debug strf("牌コード [%d] をドラにしました。", tmpDora)
			} else {
				repeat TILE_NUMERAL_COLORS
					tmpDora = tmpDora \ TILE_SUIT_STEP + cnt * TILE_SUIT_STEP
	#ifdef SANMAX
					if (tmpDora/TILE_SUIT_STEP != TILE_SUIT_CHARACTERS/TILE_SUIT_STEP)||((tmpDora == 1)||(tmpDora == 9)) {
	#endif
						incDoraFlag GameStat, Mode, tmpDora: if (Mode) {haifurecuradora tmpdora} else {haifurecdora tmpdora}
						debug strf("牌コード [%d] をドラにしました。", tmpDora)
	#ifdef SANMAX
					}
	#endif
				loop
			}
		} else {
			if (getRule(RULE_DORA_INDICATOR) == 2) {
				// 前の牌がドラ（超インフレ用）
				tmpDora = getWall(GameStat, WALL_TILECODE, getDoraPointer(GameStat)+Mode)-1
	#ifdef SANMAX
			if (tmpDora == TILE_CHARACTER_EIGHT) {tmpDora == TILE_CHARACTER_ONE}
	#endif
			if (tmpDora == TILE_SUIT_CHARACTERS+0) {tmpDora == TILE_CHARACTER_NINE}
			if (tmpDora == TILE_SUIT_CIRCLES+0) {tmpDora == TILE_CIRCLE_NINE}
			if (tmpDora == TILE_SUIT_BAMBOOS+0) {tmpDora == TILE_BAMBOO_NINE}
			if (tmpDora == TILE_WIND_MIN-1) {tmpDora == TILE_WIND_MAX}
			if (tmpDora == TILE_DRAGON_MIN-1) {tmpDora == TILE_DRAGON_MAX}
	#ifdef SANMAX
				if (tmpDora/TILE_SUIT_STEP != TILE_SUIT_CHARACTERS/TILE_SUIT_STEP) {
	#endif
					incDoraFlag GameStat, Mode, tmpDora // ドラを設定する
					debug strf("牌コード [%d] をドラにしました。", tmpDora)
					if (Mode) {haifurecuradora tmpdora} else {haifurecdora tmpdora}
	#ifdef SANMAX
				}
	#endif
			}
			if ((getRule(RULE_DORA_INDICATOR) == 1)||(getRule(RULE_DORA_INDICATOR) == 2)) {
				// 現物ドラ
				tmpDora = getWall(GameStat, WALL_TILECODE, getDoraPointer(GameStat)+Mode)
				incDoraFlag GameStat, Mode, tmpDora // ドラを設定する
				debug strf("牌コード [%d] をドラにしました。", tmpDora)
				if (Mode) {haifurecuradora tmpdora} else {haifurecdora tmpdora}
			}
			if (getRule(RULE_DORA_INDICATOR) != 1) {
				// ネクストドラ
				tmpDora = getWall(GameStat, WALL_TILECODE, getDoraPointer(GameStat)+Mode)+1
	#ifdef SANMAX
				if (tmpDora == TILE_CHARACTER_TWO) {tmpDora == TILE_CHARACTER_NINE}
	#endif
				if (tmpDora == TILE_SUIT_CHARACTERS+10) {tmpDora == TILE_CHARACTER_ONE}
				if (tmpDora == TILE_SUIT_CIRCLES+10) {tmpDora == TILE_CIRCLE_ONE}
				if (tmpDora == TILE_SUIT_BAMBOOS+10) {tmpDora == TILE_BAMBOO_ONE}
				if (tmpDora == TILE_WIND_MAX+1) {tmpDora == TILE_WIND_MIN}
				if (tmpDora == TILE_DRAGON_MAX+1) {tmpDora == TILE_DRAGON_MIN}
				incDoraFlag GameStat, Mode, tmpDora // ドラを設定する
				debug strf("牌コード [%d] をドラにしました。", tmpDora)
				if (Mode) {haifurecuradora tmpdora} else {haifurecdora tmpdora}
			}
		}
	}
	return
#global

/* 導火線の位置を調べる */
#module
#include "const.hsp"
#include "mjcore.hsp"
#deffunc calcdoukasen var GameStat
/*
		calcdoukasen p1
		導火線の位置を計算する

		p1 : 卓の状況を格納した構造体

		導火線の位置を計算します。
*/
#ifdef ALLSANMA
	if (getRule(RULE_DOUKASEN) != 0) {
		setDoukasen GameStat, ((30-((getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0)-1+(getRound(GameStat)-(getRound(GameStat)/4)))*36*2+(getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0))*2+getDrawPointer(GameStat)-1)/36)+30)\3
#ifdef SANMA4
		setDoukasen GameStat, ((30-((getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0)-1+(0))*36*2+(getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0))*2+getDrawPointer(GameStat)-1)/36)+30)\3
		if ((getRound(GameStat)\NUM_OF_PLAYERS) == 0) {tobePlayed = 0, 1, 2}
		if ((getRound(GameStat)\NUM_OF_PLAYERS) == 1) {tobePlayed = 1, 2, 3}
		if ((getRound(GameStat)\NUM_OF_PLAYERS) == 2) {tobePlayed = 2, 3, 0}
		if ((getRound(GameStat)\NUM_OF_PLAYERS) == 3) {tobePlayed = 3, 0, 1}
		setDoukasen GameStat, tobePlayed(getDoukasen(GameStat))
#endif
	}
#else
	if (getRule(RULE_DOUKASEN) != 0) {
		if (getRule(RULE_FLOWER_TILES) != 0) {
			if (getRule(RULE_FLOWER_TILES) == 3) {
				setDoukasen GameStat, ((40-((getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0)-1+(getRound(GameStat)\NUM_OF_PLAYERS))*36*3+(getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0))*2+getDrawPointer(GameStat)-1)/36)+40)\NUM_OF_PLAYERS
			} else {
				setDoukasen GameStat, ((40-((getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0)-1+(getRound(GameStat)\NUM_OF_PLAYERS))*70*3/2+(getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0))*2+getDrawPointer(GameStat)-1)/35)+40)\NUM_OF_PLAYERS
				tmp = ((getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0)-1+(getRound(GameStat)\NUM_OF_PLAYERS))*70*3/2+(getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0))*2+getDrawPointer(GameStat)-1)\70
				if ((getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0)+getRound(GameStat))\2 == 0) {
					if (tmp == 0) {setDoukasen GameStat, (40+getDoukasen(GameStat)+1)\NUM_OF_PLAYERS}
				} else {
					if (tmp == 35) {setDoukasen GameStat, (40+getDoukasen(GameStat)+1)\NUM_OF_PLAYERS}
				}
			}
		} else {
			setDoukasen GameStat, ((40-((getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0)-1+(getRound(GameStat)\NUM_OF_PLAYERS))*34*3+(getDice(GameStat, 0, 0)+getDice(GameStat, 1, 0))*2+getDrawPointer(GameStat)-1)/34)+40)\NUM_OF_PLAYERS
		}
	}
#endif
	return
#global

/* 聴牌かどうか調べる */
#module
#include "const.hsp"
#include "mjcore.hsp"
#defcfunc isTenpai var GameStat, var GameEnv, int targetPlayer
	Shanten = countshanten(GameStat, targetPlayer, SHANTEN_ALL)
	if ((getAgariHouki(GameStat, targetPlayer) == 1)||(IsRemotePlayer(GameEnv, targetPlayer) == -1)) {
		Shanten = 1 // 強制不聴扱い
	}
	if (Shanten <= 0) {return 1} else {return 0}
#global

/* 流し満貫かどうか調べる */
#module
#include "const.hsp"
#include "mjcore.hsp"
#defcfunc isNagashiMangan var GameStat, var GameEnv, int targetPlayer
	if ((getAgariHouki(GameStat, targetPlayer) == 1)||(IsRemotePlayer(GameEnv, targetPlayer) == -1)) {
		return 0 // 和了り放棄時の処理→流し満貫を認めない
	}
	YaojiuSutehai = 0
	repeat DiscardPointer(GameStat, targetPlayer), 1
		switch (getDiscard(GameStat, DISCARD_TILECODE, cnt, targetPlayer))
			case SUTEHAI_NORMAL+TILE_SUIT_CHARACTERS+1: case SUTEHAI_NORMAL+TILE_SUIT_CHARACTERS+9:
			case SUTEHAI_NORMAL+TILE_SUIT_CIRCLES+1: case SUTEHAI_NORMAL+TILE_SUIT_CIRCLES+9:
			case SUTEHAI_NORMAL+TILE_SUIT_BAMBOOS+1: case SUTEHAI_NORMAL+TILE_SUIT_BAMBOOS+9:
			case SUTEHAI_NORMAL+TILE_EAST_WIND: case SUTEHAI_NORMAL+TILE_SOUTH_WIND:
			case SUTEHAI_NORMAL+TILE_WEST_WIND: case SUTEHAI_NORMAL+TILE_NORTH_WIND:
			case SUTEHAI_NORMAL+TILE_WHITE_DRAGON: case SUTEHAI_NORMAL+TILE_GREEN_DRAGON:
			case SUTEHAI_NORMAL+TILE_RED_DRAGON:
			case SUTEHAI_RIICHI+TILE_SUIT_CHARACTERS+1: case SUTEHAI_RIICHI+TILE_SUIT_CHARACTERS+9:
			case SUTEHAI_RIICHI+TILE_SUIT_CIRCLES+1: case SUTEHAI_RIICHI+TILE_SUIT_CIRCLES+9:
			case SUTEHAI_RIICHI+TILE_SUIT_BAMBOOS+1: case SUTEHAI_RIICHI+TILE_SUIT_BAMBOOS+9:
			case SUTEHAI_RIICHI+TILE_EAST_WIND: case SUTEHAI_RIICHI+TILE_SOUTH_WIND:
			case SUTEHAI_RIICHI+TILE_WEST_WIND: case SUTEHAI_RIICHI+TILE_NORTH_WIND:
			case SUTEHAI_RIICHI+TILE_WHITE_DRAGON: case SUTEHAI_RIICHI+TILE_GREEN_DRAGON:
			case SUTEHAI_RIICHI+TILE_RED_DRAGON:
				YaojiuSutehai++
			swbreak
		swend
	loop
	if (YaojiuSutehai == DiscardPointer(GameStat, targetPlayer)) {return 1} else {return 0}
#global
