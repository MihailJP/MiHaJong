/*=============================
 * HSP麻雀クライアントMiHaJong
 *      [メインルーチン]
 *=============================
 */

/* ゲーム開始処理 */
*startgame
	/* 変数類の初期化 */
	TableEnvInit GameEnv
	if (vartype(GameStat) == vartype("struct")) {
		if (varuse(GameStat)) {
			delmod GameStat
		}
	}
	newmod GameStat, gameStruct
	vanish
	info "ゲーム情報を初期化しました。"
	serverreceive_init
	bgmplay MUS_TITLE	// タイトル曲を流す
	gosub *selmode	// タイトル画面
	gosub *chrshuffle	// 親決めの処理
	gosub *gameinit	// 半荘の初期化処理
	font fontname, 18, 1

/* 半荘の進行 */
repeat
	info strf("局番号 [%d] を開始しました。", getRound(GameStat))
	if (getGameMode(GameEnv) == GAMEMODE_CLIENT) {
		sockput "8\n", SOCK_CHAT+0 // チャットを同期
	}
	/* ウォッチモードの時は視点を親に移す */
	setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, -1
	if (GetWatchModeFlag(GameEnv) == 1) {
		setPlayer GameStat, getRound(GameStat)\NUM_OF_PLAYERS
	}
	/* 破回八連荘の後始末 */
	if (getAgariChain(GameStat) == -1) {setAgariChain GameStat, 1}
	/* 半荘の初期化と配牌を行なう */
	gosub *tableinit
	/* デバッグ用のコード(バグ検証のときを除いてコメントアウトしておくこと！) */
//	tmpTiles = 04,05,06,08,08,12,13,14,14,15,16,26,28
//	repeat 13: setHand GameStat, 0, cnt, (getPlayer(GameStat)+3)\4, tmpTiles(cnt): loop
//	tmpTiles = 04,04,06,07,08,16,17,18,26,26,27,28,28
//	repeat 13: setHand GameStat, 0, cnt, (getPlayer(GameStat)+1)\4, tmpTiles(cnt): loop
//	setHand GameStat, 0, 0, (getPlayer(GameStat))\4, 27
//	tmpTiles = 12,12,12,13,14,15,16,17,17,17,36,36,36
//	repeat 13: setHand GameStat, 0, cnt, (getPlayer(GameStat))\4, tmpTiles(cnt): loop
	/* 配牌終了時の処理 */
	repeat NUM_OF_PLAYERS: setHandStat GameStat, cnt, 0:lipai GameStat, cnt: loop
	setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, getRound(GameStat)\NUM_OF_PLAYERS // 最初に親から捨牌を行なう
	info "配牌を完了しました。"
	/* 摸打ループ */
	repeat
		info strf("プレイヤー [%d] のツモ番です。", getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))
		/* 変数の初期化 */
		calcdoukasen GameStat // 導火線の位置を更新
		if (getKangFlag(GameStat, KANG_FLAG) == 0) { setKangFlag GameStat, KANG_CHAINFLAG, 0: setKangFlag GameStat, KANG_TOPFLAG, 0 /* 連続槓の回数と頭槓和フラグをリセット */ }
		setCurrentDiscard GameStat, CURRENTDISCARD_TILECODE, 0
		/* ウォッチモードの時は視点をツモ番の人に移す */
		if (GetWatchModeFlag(GameEnv) == 1) {
			setPlayer GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
		}
		/* 再描画 */
		redrscreen
		/* 摸打の処理 */
		getdahai GameStat, GameEnv
		DiscardTileIndex = stat
		if (DiscardTileIndex == DAHAI_TYPE_DISCONNECT) {break}
		/* ウェイトを入れる */
//		if (((getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE) != getPlayer(GameStat))&&(IsRemotePlayer(GameEnv, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0))||(GetWatchModeFlag(GameEnv) == 1)) {
//			await 700
//		} else {
			await 0
//		}
		// 打牌コード
		// ０〜１２…それぞれの手牌
		// １３…ツモ切り（何面子鳴いていてもこの番号で固定）
		// ＋２０…暗槓
		// ＋４０…加槓
		// ＋６０…リーチ
		// −１…ツモ和了り
		// −２…九種九牌
		info strf("プレイヤー [%d] 打牌コード [%d]", getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), DiscardTileIndex)
		/* 立直していない同順振聴ならその期限のため振聴を解除する */
		if (getRichiFlag(GameStat, RICHI_FLAG, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == RIICHI_NO) {setDoujunFuriten GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 0}
		/* 自摸和の処理 */
		if (DiscardTileIndex == DAHAI_TYPE_AGARI) {
			haifurectsumo GameStat // 牌譜に記録
			/* 八連荘判定用の変数 */
			if (getRule(RULE_PAARENCHAN) != 0) {
				if (getLastAgariPlayer(GameStat) == getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) {
					incAgariChain GameStat
				} else {
					if ((getRule(RULE_BREAKING_PAARENCHAN) != 0)&&(getAgariChain(GameStat) == 7)) {setAgariChain GameStat, -1: setLastAgariPlayer GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_AGARI)}
					else {setAgariChain GameStat, 1: setLastAgariPlayer GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_AGARI)}
				}
			}
			/* 自摸和したことを変数に設定 */
			setTsumoAgariFlag GameStat, 1
			countyaku GameStat, yakuInfo, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
			if ((getYakuInfo(yakuInfo, YAKUINF_HAN_BASE) <= getShibari(GameStat))||((getRule(RULE_RIICHI_SHIBARI) != 0)&&(getRichiFlag(GameStat, RICHI_FLAG, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == RIICHI_NO))||((getPao(GameStat, PAO_PLAYER_AGARI, PAO_YAKU_MINKAN) != -1)&&(getRule(RULE_MINKAN_PAO) == 6))) {
				/* 縛りを満たしていない場合(役が無いなど)…錯和として局を終了する */
				RoundEndType = ENDKYOKU_CHONBO
			} else {
				/* 縛りを満たすなら和了りとして成立 */
				RoundEndType = ENDKYOKU_AGARI
			}
			setTsumoAgariFlag GameStat, 1
			setCurrentPlayer GameStat, CURRENTPLAYER_AGARI, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
			setCall getCurrentPlayer(GameStat, CURRENTPLAYER_AGARI), "ツモ"
			if (getHeavenHandFlag(GameStat) == 1) {setCall getCurrentPlayer(GameStat, CURRENTPLAYER_AGARI), "ロン"} //天和の時はロンと言う慣わし
			setHandStat GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_AGARI), 1
			if (getHeavenHandFlag(GameStat) == 1) {dsplay VOX_RON} else {dsplay VOX_TSUMO}
			redrscreen: break
		}
#ifndef SANMAS
		/* 九種九牌が宣言された場合 */
		if ((DiscardTileIndex == DAHAI_TYPE_KYUUSHU)&&(getRule(RULE_NINE_TERMINALS) != 3)) {
			DiscardTileIndex = DAHAI_TYPE_NORMAL+TSUMOHAI_INDEX // 九種流しができない時はツモ切りとみなす
			targetPlayer = getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE): DaoPaiAbilityFlag = chkdaopaiability(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))
			if (DaoPaiAbilityFlag) {
				if (getFirstDrawFlag(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))) {
					RoundEndType = ENDKYOKU_KYUUSHUKYUUHAI
					setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "九種九牌"
					setHandStat GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 1
					dsplay VOX_KYUUSHU
					redrscreen: break
				}
			}
			warn strf("九種九牌はできません。打牌コード [%d] に補正しました。", DiscardTileIndex)
		}
		if ((DiscardTileIndex == DAHAI_TYPE_KYUUSHU)&&(getRule(RULE_NINE_TERMINALS) == 3)) {
			DiscardTileIndex = DAHAI_TYPE_NORMAL+TSUMOHAI_INDEX // 九種流しができない時はツモ切りとみなす
			warn strf("九種九牌はできません。打牌コード [%d] に補正しました。", DiscardTileIndex)
		}
#endif
		/* 打牌を牌譜に記録する */
		if ((DiscardTileIndex >= DAHAI_TYPE_NORMAL)&&(DiscardTileIndex < DAHAI_TYPE_NORMAL+DAHAI_TYPE_STEP)) {
			haifurecmota GameStat, DiscardTileIndex
		}
		if ((DiscardTileIndex >= DAHAI_TYPE_RIICHI)&&(DiscardTileIndex < DAHAI_TYPE_RIICHI+DAHAI_TYPE_STEP)) {
			haifurecmota GameStat, DiscardTileIndex
		}
		if ((DiscardTileIndex >= DAHAI_TYPE_OPENRIICHI)&&(DiscardTileIndex < DAHAI_TYPE_OPENRIICHI+DAHAI_TYPE_STEP)) {
			haifurecmota GameStat, DiscardTileIndex
		}
#ifndef SANMAS
		/* 花牌を抜いた場合の処理 */
		if ((DiscardTileIndex >= DAHAI_TYPE_KAN)&&(DiscardTileIndex < DAHAI_TYPE_KAN+DAHAI_TYPE_STEP)) {
			if (getHand(GameStat, HAND_TILECODE, DiscardTileIndex-DAHAI_TYPE_KAN, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) > TILE_SUIT_FLOWERS) {
				DiscardTileIndex += (DAHAI_TYPE_FLOWER-DAHAI_TYPE_KAN)
				info strf("花牌の処理に移ります。打牌コード [%d] に補正しました。", DiscardTileIndex)
			}
		}
#ifdef SANMAX
		/* ガリ三麻ルールで北風牌を抜いたときの処理 */
		/* このゲームではどんな手でも(国士や大四喜でなくてもいい)
		   抜き北をロンできるルール */
		if ((DiscardTileIndex >= DAHAI_TYPE_FLOWER)&&(DiscardTileIndex < DAHAI_TYPE_FLOWER+DAHAI_TYPE_STEP)) {
			fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_NORTH
			if (stat == 1) {break}
			continue getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
		}
#else
		/* 花牌を抜いたときの処理 */
		/* このゲームは七搶一がないので花牌でロンされることは無い */
		if ((DiscardTileIndex >= DAHAI_TYPE_FLOWER)&&(DiscardTileIndex < DAHAI_TYPE_FLOWER+DAHAI_TYPE_STEP)) {
			fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_FLOWER
			if (stat == 1) {break}
			continue getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
		}
#endif
#endif
		/* 暗槓するときの処理 */
		if ((DiscardTileIndex >= DAHAI_TYPE_KAN)&&(DiscardTileIndex < DAHAI_TYPE_KAN+DAHAI_TYPE_STEP)&&(getDrawPointer(GameStat) < (getRinshanPointer(GameStat) - (getDeadWallLength(GameStat)-1)))&&(getTotalKang(GameStat) < (4+getRule(RULE_FIFTH_KONG)))) {
			if ((getRule(RULE_MINKAN_PAO) == 1)||(getRule(RULE_MINKAN_PAO) == 4)) {
				setPao GameStat, PAO_PLAYER_PAO, PAO_YAKU_MINKAN, -1
				setPao GameStat, PAO_PLAYER_AGARI, PAO_YAKU_MINKAN, -1
			}
			fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_ANKAN
			if (stat == 1) {break}
			/* 槓をすると嶺上牌の分自摸が増えるので次の打牌へ */
			continue getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
		}
		/* 加槓する時の処理 */
		if ((DiscardTileIndex >= DAHAI_TYPE_KAKAN)&&(DiscardTileIndex < DAHAI_TYPE_KAKAN+DAHAI_TYPE_KAN)&&(getDrawPointer(GameStat) < (getRinshanPointer(GameStat) - (getDeadWallLength(GameStat)-1)))&&(getTotalKang(GameStat) < (4+getRule(RULE_FIFTH_KONG)))) {
			if ((getRule(RULE_MINKAN_PAO) == 1)||(getRule(RULE_MINKAN_PAO) == 4)) {
				setPao GameStat, PAO_PLAYER_PAO, PAO_YAKU_MINKAN, -1
				setPao GameStat, PAO_PLAYER_AGARI, PAO_YAKU_MINKAN, -1
			}
			fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_KAKAN
			if (stat == 1) {break}
			/* 槓をすると嶺上牌の分自摸が増えるので次の打牌へ */
			continue getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
		}
		setKangFlag GameStat, KANG_FLAG, 0 // 嶺上開花のフラグを降ろす
		setPao GameStat, PAO_PLAYER_PAO, PAO_YAKU_MINKAN, -1
		setPao GameStat, PAO_PLAYER_AGARI, PAO_YAKU_MINKAN, -1
		/* 立直をするときの処理 */
		if ((DiscardTileIndex >= DAHAI_TYPE_RIICHI)&&(DiscardTileIndex < DAHAI_TYPE_RIICHI+DAHAI_TYPE_STEP)) {
			if (tilesLeft(GameStat) < NUM_OF_ACTUAL_PLAYERS) {
				// 残り４枚未満の時はリーチ無効
				DiscardTileIndex -= DAHAI_TYPE_RIICHI-DAHAI_TYPE_NORMAL
				warn strf("山牌の残数要件を満たしていません。打牌コード [%d] に補正しました。", DiscardTileIndex)
			} else: if (isRichiReqSatisfied(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0) {
				// 点棒条件を満たしていない時はリーチ無効
				DiscardTileIndex -= DAHAI_TYPE_RIICHI-DAHAI_TYPE_NORMAL
				warn strf("持ち点の要件を満たしていません。打牌コード [%d] に補正しました。", DiscardTileIndex)
			}
		}
		/* オープン立直をするときの処理 */
		if ((DiscardTileIndex >= DAHAI_TYPE_OPENRIICHI)&&(DiscardTileIndex < DAHAI_TYPE_OPENRIICHI+DAHAI_TYPE_STEP)) {
			if (tilesLeft(GameStat) < NUM_OF_ACTUAL_PLAYERS) {
				// 残り４枚未満の時はリーチ無効
				DiscardTileIndex -= DAHAI_TYPE_OPENRIICHI-DAHAI_TYPE_NORMAL
				warn strf("山牌の残数要件を満たしていません。打牌コード [%d] に補正しました。", DiscardTileIndex)
			} else: if (isRichiReqSatisfied(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0) {
				// 点棒条件を満たしていない時はリーチ無効
				DiscardTileIndex -= DAHAI_TYPE_OPENRIICHI-DAHAI_TYPE_NORMAL
				warn strf("持ち点の要件を満たしていません。打牌コード [%d] に補正しました。", DiscardTileIndex)
			}
		}
		if (getRule(RULE_OPEN_RIICHI) == 0) {
			// オープン立直無しの時
			if ((DiscardTileIndex >= DAHAI_TYPE_OPENRIICHI)&&(DiscardTileIndex < DAHAI_TYPE_OPENRIICHI+DAHAI_TYPE_STEP)) {
				DiscardTileIndex = (DiscardTileIndex \ DAHAI_TYPE_STEP) + DAHAI_TYPE_RIICHI
				warn strf("オープン立直はできません。打牌コード [%d] に補正しました。", DiscardTileIndex)
			}
		}
		/* 立直を宣言する */
		if ((DiscardTileIndex >= DAHAI_TYPE_OPENRIICHI)&&(DiscardTileIndex < DAHAI_TYPE_OPENRIICHI+DAHAI_TYPE_STEP)) {
			setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "リーチ"
			dsplay VOX_RICHI
			redrscreen
			await 1000
			setHandStat GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 3
			if ((getRichiFlag(GameStat, RICHI_OPENFLAG, 0)+getRichiFlag(GameStat, RICHI_OPENFLAG, 1)+getRichiFlag(GameStat, RICHI_OPENFLAG, 2)+getRichiFlag(GameStat, RICHI_OPENFLAG, 3)) == 0) {
				bgmplay_short MUS_OPENRICHI
			}
			setRichiFlag GameStat, RICHI_OPENFLAG, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 1
			vanish: commonswitch GameStat, GameEnv
		}
		if ((DiscardTileIndex >= DAHAI_TYPE_RIICHI)&&(DiscardTileIndex < DAHAI_TYPE_RIICHI+DAHAI_TYPE_STEP)) {
			setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "リーチ"
			dsplay VOX_RICHI
			redrscreen
			await 1000
			if ((getRichiFlag(GameStat, RICHI_OPENFLAG, 0)+getRichiFlag(GameStat, RICHI_OPENFLAG, 1)+getRichiFlag(GameStat, RICHI_OPENFLAG, 2)+getRichiFlag(GameStat, RICHI_OPENFLAG, 3)) == 0) {
				if ((getRichiFlag(GameStat, RICHI_FLAG, 0) == RIICHI_NO)&&(getRichiFlag(GameStat, RICHI_FLAG, 1) == RIICHI_NO)&&(getRichiFlag(GameStat, RICHI_FLAG, 2) == RIICHI_NO)&&(getRichiFlag(GameStat, RICHI_FLAG, 3) == RIICHI_NO)) {
					if (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE) == getPlayer(GameStat)) {
						bgmplay_short MUS_RICHI2
					} else {
						bgmplay_short MUS_RICHI1
					}
					await 0
				} else {
					if (GetWatchModeFlag(GameEnv) == 0) {
						if (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE) == getPlayer(GameStat)) {
							bgmplay_short MUS_RICHI3
						}
					}
					await 0
				}
			}
			vanish: commonswitch GameStat, GameEnv
		}
		/* 打牌を記録する */
		setCurrentDiscard GameStat, CURRENTDISCARD_TILECODE, getHand(GameStat, HAND_TILECODE, (DiscardTileIndex\DAHAI_TYPE_STEP), getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))
		setCurrentDiscard GameStat, CURRENTDISCARD_REDTILE, getHand(GameStat, HAND_REDTILE, (DiscardTileIndex\DAHAI_TYPE_STEP), getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))
		if ((DiscardTileIndex >= DAHAI_TYPE_RIICHI)&&(DiscardTileIndex < DAHAI_TYPE_RIICHI+DAHAI_TYPE_STEP)) {
			/* 立直宣言牌の場合 */
			setDiscard GameStat, DISCARD_TILECODE, DiscardPointer(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))+1, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)+SUTEHAI_RIICHI
		} else:if ((DiscardTileIndex >= DAHAI_TYPE_OPENRIICHI)&&(DiscardTileIndex < DAHAI_TYPE_OPENRIICHI+DAHAI_TYPE_STEP)) {
			/* オープン立直宣言牌の場合 */
			setDiscard GameStat, DISCARD_TILECODE, DiscardPointer(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))+1, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)+SUTEHAI_RIICHI
		} else {
			/* それ以外の場合 */
			setDiscard GameStat, DISCARD_TILECODE, DiscardPointer(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))+1, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
		}
		setDiscard GameStat, DISCARD_REDTILE, DiscardPointer(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))+1, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getCurrentDiscard(GameStat, CURRENTDISCARD_REDTILE)
		if (((DiscardTileIndex\DAHAI_TYPE_STEP) == TSUMOHAI_INDEX)&&(getHeavenHandFlag(GameStat) == 0)) {
			setDiscard GameStat, DISCARD_THROUGH, DiscardPointer(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))+1, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 1
		}
		DiscardPointerIncrement GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
		setHand GameStat, HAND_TILECODE, (DiscardTileIndex\DAHAI_TYPE_STEP), getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 0
		/* 一発のフラグを降ろす */
		if (getRichiFlag(GameStat, RICHI_FLAG, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == RIICHI_IPPATSU) {setRichiFlag GameStat, RICHI_FLAG, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), RIICHI_YES}
		if (getRichiFlag(GameStat, RICHI_FLAG, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == RIICHI_DOUBLE_IPPATSU) {setRichiFlag GameStat, RICHI_FLAG, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), RIICHI_DOUBLE}
		/* 自動的に理牌を行なう */
		lipai GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
		// このとき牌を捨てているはず 表示バグ防止のため
		repeat NUM_OF_PLAYERS: setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, cnt, 0: loop
		/* 立直をした直後の場合、千点を供託し一発のフラグを立てる */
		if ((DiscardTileIndex >= DAHAI_TYPE_OPENRIICHI)&&(DiscardTileIndex < DAHAI_TYPE_OPENRIICHI+DAHAI_TYPE_STEP)) {
			setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), ""
			setRichiFlag GameStat, RICHI_FLAG, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), RIICHI_IPPATSU+(getFirstDrawFlag(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))*(RIICHI_DOUBLE_IPPATSU-RIICHI_IPPATSU))
			DiscardTileIndex -= DAHAI_TYPE_OPENRIICHI
			addDeposit GameStat, 1: addScore GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 0, -10
			targetPlayer = getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE): gosub *chkopenmachi
		}
		if ((DiscardTileIndex >= DAHAI_TYPE_RIICHI)&&(DiscardTileIndex < DAHAI_TYPE_RIICHI+DAHAI_TYPE_STEP)) {
			setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), ""
			setRichiFlag GameStat, RICHI_FLAG, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), RIICHI_IPPATSU+(getFirstDrawFlag(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))*(RIICHI_DOUBLE_IPPATSU-RIICHI_IPPATSU))
			DiscardTileIndex -= DAHAI_TYPE_RIICHI
			addDeposit GameStat, 1: addScore GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 0, -10
		}
		/* 天和や地和のフラグを降ろす */
		setHeavenHandFlag GameStat, 0
		setFirstDrawFlag GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 0
		/* 打牌するときの音を鳴らす */
		/* ドラを捨てる時は強打の音にする */
		if (getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE) > TILE_SUIT_FLOWERS) {
			dsplay SND_DAHAI2
		} else:if ((getCurrentDiscard(GameStat, CURRENTDISCARD_REDTILE) == 1)||(getDoraFlag(GameStat, DORA_OMOTE, getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)) > 0)) {
			dsplay SND_DAHAI2
		} else:if ((getCurrentDiscard(GameStat, CURRENTDISCARD_REDTILE) == 2)&&(getRule(RULE_BLUE_TILES) != 2)) {
			dsplay SND_DAHAI2
		} else {
			dsplay SND_DAHAI1
		}
		/* このとき牌を捨てているはずなので、バグ防止のための処理 */
		repeat NUM_OF_PLAYERS: setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, cnt, 0: loop
		/* 再描画 */
		redrscreen
		await 80
		/* 栄和の処理 */
		gosub *ronhuproc // 栄和の処理
		await 0
		if ((RoundEndType = ENDKYOKU_TRIPLERON)||(RoundEndType = ENDKYOKU_DISCONNECT)) {break}
		if (RonPlayers(GameStat) > 0) {break}
		/* 四開槓なら流す */
		if (getRule(RULE_FOUR_KONG_RYUUKYOKU) != 2) {
			if ((getTotalKang(GameStat) == 4)&&(getNumberOfQuads(GameStat, 0) < 4)&&(getNumberOfQuads(GameStat, 1) < 4)&&(getNumberOfQuads(GameStat, 2) < 4)&&(getNumberOfQuads(GameStat, 3) < 4)) {
				RoundEndType = ENDKYOKU_SUUKAIKAN
				redrscreen: break
			}
		}
#ifdef ALLSANMA
		// 三人立直の判定
		if (getRule(RULE_FOUR_RIICHI_RYUUKYOKU) != 0) {
#ifdef SANMA4
			if (((getRichiFlag(GameStat, RICHI_FLAG, 0) != RIICHI_NO)||(playerwind(0, getRound(GameStat)) == PLAYER_NORTH))&&((getRichiFlag(GameStat, RICHI_FLAG, 1) != RIICHI_NO)||(playerwind(1, getRound(GameStat)) == PLAYER_NORTH))&&((getRichiFlag(GameStat, RICHI_FLAG, 2) != RIICHI_NO)||(playerwind(2, getRound(GameStat)) == PLAYER_NORTH))&&((getRichiFlag(GameStat, RICHI_FLAG, 3) != RIICHI_NO)||(playerwind(3, getRound(GameStat)) == PLAYER_NORTH))) {
#else
			if ((getRichiFlag(GameStat, RICHI_FLAG, 0)*getRichiFlag(GameStat, RICHI_FLAG, 1)*getRichiFlag(GameStat, RICHI_FLAG, 2)) != 0) {
#endif
				RoundEndType = ENDKYOKU_SUUCHARIICHI: break
			}
		}
		// 三風連打の判定
		if (getRule(RULE_FOUR_WIND_RYUUKYOKU) != 0) {
#ifdef SANMA4
			if (((DiscardPointer(GameStat, 0) == 1)||(playerwind(0, getRound(GameStat)) == PLAYER_NORTH))&&((DiscardPointer(GameStat, 1) == 1)||(playerwind(1, getRound(GameStat)) == PLAYER_NORTH))&&((DiscardPointer(GameStat, 2) == 1)||(playerwind(2, getRound(GameStat)) == PLAYER_NORTH))&&((DiscardPointer(GameStat, 3) == 1)||(playerwind(3, getRound(GameStat)) == PLAYER_NORTH))) {
				if (((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) == getDiscard(GameStat, DISCARD_TILECODE, 1, 1))||(playerwind(1, getRound(GameStat)) == PLAYER_NORTH))&&((getDiscard(GameStat, DISCARD_TILECODE, 1, 1) == getDiscard(GameStat, DISCARD_TILECODE, 1, 2))||(playerwind(2, getRound(GameStat)) == PLAYER_NORTH))&&((getDiscard(GameStat, DISCARD_TILECODE, 1, 2) == getDiscard(GameStat, DISCARD_TILECODE, 1, 3))||(playerwind(3, getRound(GameStat)) == PLAYER_NORTH))&&((getDiscard(GameStat, DISCARD_TILECODE, 1, 3) == getDiscard(GameStat, DISCARD_TILECODE, 1, 0))||(playerwind(0, getRound(GameStat)) == PLAYER_NORTH))) {
#else
			if ((DiscardPointer(GameStat, 0) == 1)&&(DiscardPointer(GameStat, 1) == 1)&&(DiscardPointer(GameStat, 2) == 1)) {
				if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) == getDiscard(GameStat, DISCARD_TILECODE, 1, 1))&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 1) == getDiscard(GameStat, DISCARD_TILECODE, 1, 2))) {
#endif
					if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) >= TILE_WIND_MIN)&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 0) <= TILE_WIND_MAX)) {
						RoundEndType = ENDKYOKU_SUUFONRENDA: break
					}
				}
			}
		}
#else
		// 四人立直の判定
		if (((getRichiFlag(GameStat, RICHI_FLAG, 0)*getRichiFlag(GameStat, RICHI_FLAG, 1)*getRichiFlag(GameStat, RICHI_FLAG, 2)*getRichiFlag(GameStat, RICHI_FLAG, 3)) != 0)&&(getRule(RULE_FOUR_RIICHI_RYUUKYOKU) != 2)) {
			RoundEndType = ENDKYOKU_SUUCHARIICHI: break
		}
		// 四風連打の判定
		if (getRule(RULE_FOUR_WIND_RYUUKYOKU) != 2) {
			if ((DiscardPointer(GameStat, 0) == 1)&&(DiscardPointer(GameStat, 1) == 1)&&(DiscardPointer(GameStat, 2) == 1)&&(DiscardPointer(GameStat, 3) == 1)) {
				if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) == getDiscard(GameStat, DISCARD_TILECODE, 1, 1))&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 1) == getDiscard(GameStat, DISCARD_TILECODE, 1, 2))&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 2) == getDiscard(GameStat, DISCARD_TILECODE, 1, 3))) {
					if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) >= TILE_WIND_MIN)&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 0) <= TILE_WIND_MAX)) {
						RoundEndType = ENDKYOKU_SUUFONRENDA: break
					}
				}
			}
		}
#endif
		repeat NUM_OF_PLAYERS: setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, cnt, 0: loop // バグ防止のため
		if (((getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE) == getPreviousMeld(GameStat, PREVMELD_TILECODE))||(getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE) == getPreviousMeld(GameStat, PREVMELD_STEPPED)))&&(getAgariHouki(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0)) {
			// 喰い替えの場合の処理
			switch getRule(RULE_KUIKAE)
				case 0: case 3:
					/* 和了り放棄とする設定 */
					info strf("喰い変えを検出しました。和了り放棄として扱います。打牌 [%d] 鳴いた牌 [%d]", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), getPreviousMeld(GameStat, PREVMELD_TILECODE))
					dsplay SND_CUOHU
					repeat 2
						setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "喰替"
						redrscreen: await 1500
						setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "和了放棄"
						redrscreen: await 1500
					loop
					setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), ""
					redrscreen
					/* 和了り放棄は以降強制ツモ切り、強制不聴扱いとなります */
					setAgariHouki GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 1
					if (GetWatchModeFlag(GameEnv) == 0) {statmes "和了り放棄：強制ツモ切りされます"}
					vanish: commonswitch GameStat, GameEnv
					swbreak
				case 1: case 4:
					/* 直ちに錯和とする設定 */
					info strf("喰い変えを検出しました。チョンボとして扱います。打牌 [%d] 鳴いた牌 [%d]", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), getPreviousMeld(GameStat, PREVMELD_TILECODE))
					dsplay SND_CUOHU
					RoundEndType = ENDKYOKU_CHONBO: setTsumoAgariFlag GameStat, AGARI_KUIKAE
					setCurrentPlayer GameStat, CURRENTPLAYER_AGARI, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
					setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "錯和"
					redrscreen: await 1500
					/* 局を打ち切り、満貫罰符の支払いに進む */
					break
			swend
		}
		/* 多牌や少牌をしていないかのチェック */
		tmptilecnt = 0
		repeat NUM_OF_TILES_IN_HAND
			if (getHand(GameStat, HAND_TILECODE, cnt, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) > 0) {tmptilecnt++}
		loop
		tmptilecnt += (MeldPointer(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) * 3)
		if ((tmptilecnt != (NUM_OF_TILES_IN_HAND-1))&&(getAgariHouki(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0)) {
//			多牌や少牌の場合の処理(通常起きることはないはずだが…)
			if (tmptilecnt > (NUM_OF_TILES_IN_HAND-1)) {
				warn "多牌を検出しました。和了り放棄として扱いますが、摸打の処理で不整合が起きていた可能性があります。"
			} else {
				warn "少牌を検出しました。和了り放棄として扱いますが、摸打の処理で不整合が起きていた可能性があります。"
			}
			dsplay SND_CUOHU
			repeat 2
				if (tmptilecnt > (NUM_OF_TILES_IN_HAND-1)) {
					setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "多牌"
				} else {
					setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "少牌"
				}
				redrscreen: await 1500
				setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "和了放棄"
				redrscreen: await 1500
			loop
			setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), ""
			redrscreen
			setAgariHouki GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 1
			if (GetWatchModeFlag(GameEnv) == 0) {statmes "和了り放棄：強制ツモ切りされます"}
			vanish: commonswitch GameStat, GameEnv
		}
		await 0
		/* 荒牌の場合ここで終了する(河底牌は吃ポンできないがロンはできる) */
		if (getDrawPointer(GameStat) == (getRinshanPointer(GameStat) - (getDeadWallLength(GameStat)-1))) {RoundEndType = ENDKYOKU_RYUUKYOKU: break}
		/* 捨牌をポン、または大明槓する場合の処理 */
		/* 同じ牌は４枚しかないので、ポンと明槓は同時に起こることがない */
		if (getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 3)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 3) > 1) {
			error "複数同時のポン・槓が宣言されています。"
		}
		repeat NUM_OF_PLAYERS: await 0
			/* 捨牌をポンする場合 */
			if (getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, cnt) == 1) {
				setCurrentPlayer GameStat, CURRENTPLAYER_PASSIVE, cnt // 鳴いたプレイヤーを設定
				fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_PON
				break
			}
			/* 明槓の場合 */
			if ((getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, cnt) == 1)&&(getTotalKang(GameStat) < (4+getRule(RULE_FIFTH_KONG)))) {
				setCurrentPlayer GameStat, CURRENTPLAYER_PASSIVE, cnt // 鳴いたプレイヤーを設定
				fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_DAIMINKAN
				break
			}
		loop
		/* 鳴きがあった場合、鳴いたプレーヤーに順番を移して戻る */
		/* 吃とポンが同時に起こった場合、ポンを優先する */
		if ((getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 3)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 3)) > 0) {
			setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, getCurrentPlayer(GameStat, CURRENTPLAYER_PASSIVE)
			continue
#ifndef ALLSANMA
		} else {
			/* 吃の処理 */
			/* 三人打ちでは吃なし */
			if (getDeclarationFlag(GameStat, DECLARATIONFLAG_CHI, ShimochaOf(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))) > 0) {
				setCurrentPlayer GameStat, CURRENTPLAYER_PASSIVE, ShimochaOf(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) // 吃ができるのは上家の捨牌のみ
				fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_CHII
				setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, getCurrentPlayer(GameStat, CURRENTPLAYER_PASSIVE)
				continue
			}
#endif
		}
		/* ウェイトを入れる */
		await 100
		/* バグ防止のアレ */
		repeat NUM_OF_PLAYERS: setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, cnt, 0: loop
		/* 次のプレイヤーが牌を自摸る */
		incDrawPointer GameStat: setHeavenHandFlag GameStat, 0
#ifdef SANMAT
		setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)+1)\NUM_OF_ACTUAL_PLAYERS
#else
#ifdef SANMA4
		/* 北家をスキップ */
		if (playerWind(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getRound(GameStat)) == PLAYER_WEST) {
			setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)+1)\NUM_OF_PLAYERS
		}
#endif
		setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)+1)\NUM_OF_PLAYERS
#endif
		setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getWall(GameStat, WALL_TILECODE, getDrawPointer(GameStat))
		setHand GameStat, HAND_REDTILE, TSUMOHAI_INDEX, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getWall(GameStat, WALL_REDTILE, getDrawPointer(GameStat))
		setPreviousMeld GameStat, PREVMELD_TILECODE, -999
		setPreviousMeld GameStat, PREVMELD_STEPPED, -999
		dsplay SND_TSUMO
		if (tilesLeft(GameStat) < 10) {
			dsplay SND_COUNTDOWN
		}
		// 打牌へ戻る
	loop
	OrigHonba = getHonba(GameStat): OrigTurn = getRound(GameStat)
	endround GameStat, GameEnv, RoundEndType, yakuInfo, OrigTurn, OrigHonba
	await 5000
	// ハコ割れ終了
	if (getRule(RULE_PENALTY_NEGATIVE) != 6) {
		if (isDobon(GameStat,PLAYER_EAST)) {break}
		if (isDobon(GameStat,PLAYER_SOUTH)) {break}
		if (isDobon(GameStat,PLAYER_WEST)) {break}
#ifndef SANMAT
		if (isDobon(GameStat,PLAYER_NORTH)) {break}
#endif
	}
	// 和了り止め
	if (getRule(RULE_AGARIYAME) != 1) {
		if (((getRound(GameStat)+(getRoundLoop(GameStat)*16)) == getGameLength(GameStat))&&((OrigTurn+(getRoundLoop(GameStat)*16)) == getGameLength(GameStat))&&((RoundEndType == ENDKYOKU_AGARI)||(getRule(RULE_AGARIYAME) == 2))) {
			calcRank Rank, GameStat
#ifdef SANMAT
			if ((Rank(getRound(GameStat)\NUM_OF_PLAYERS) == 1)&&(getScore(GameStat,getRound(GameStat)\NUM_OF_PLAYERS) >= 400)) {break}
#else
			if ((Rank(getRound(GameStat)\NUM_OF_PLAYERS) == 1)&&(getScore(GameStat,getRound(GameStat)\NUM_OF_PLAYERS) >= 300)) {break}
#endif
		}
	}
#ifdef SANMAT
	if (getRound(GameStat)\NUM_OF_PLAYERS == 3) {incRound GameStat}
#endif
	// 東北廻しのとき
	if ((getRound(GameStat) == 4)&&(getRule(RULE_GAME_LENGTH) == 3)) {setRound GameStat, 12}
	// 東々廻しのとき
	if ((getRound(GameStat) == 4)&&((getRule(RULE_GAME_LENGTH) == 5)||(getRule(RULE_GAME_LENGTH) == 7))) {setRound GameStat, 16}
	// 通常の半荘終了時（トップが３００００点未満だと西入サドンデス）
#ifdef SANMAT
	if ((((getRound(GameStat)+(getRoundLoop(GameStat)*16)) >= (getGameLength(GameStat)+1)))&&((getScore(GameStat,0) >= 400)||(getScore(GameStat,1) >= 400)||(getScore(GameStat,2) >= 400))) {break}
#else
	if ((((getRound(GameStat)+(getRoundLoop(GameStat)*16)) >= (getGameLength(GameStat)+1)))&&((getScore(GameStat,0) >= 300)||(getScore(GameStat,1) >= 300)||(getScore(GameStat,2) >= 300)||(getScore(GameStat,3) >= 300))) {break}
#endif
	// 北場終了の場合は帰り東へ
	if (getRound(GameStat) == 16) {incRoundLoop GameStat: setRound GameStat, 0}
loop
// 半荘終了時
#include "hancnend.hsp"
stop
