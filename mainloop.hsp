/*=============================
 * HSP麻雀クライアントMiHaJong
 *      [メインルーチン]
 *=============================
 */

/* ゲーム開始処理 */
*startgame
	/* 変数類の初期化 */
	TableEnvInit GameEnv
	if (vartype(GameStat) == vartype("struct")) {
		if (varuse(GameStat)) {
			delmod GameStat
		}
	}
	newmod GameStat, gameStruct
	vanish
	info "ゲーム情報を初期化しました。"
	serverreceive_init
	bgmplay MUS_TITLE	// タイトル曲を流す
	gosub *selmode	// タイトル画面
	gosub *chrshuffle	// 親決めの処理
	gosub *gameinit	// 半荘の初期化処理
	font fontname, 18, 1

/* 半荘の進行 */
repeat
	info strf("局番号 [%d] を開始しました。", getRound(GameStat))
	if (getGameMode(GameEnv) == GAMEMODE_CLIENT) {
		sockput "8\n", SOCK_CHAT+0 // チャットを同期
	}
	/* ウォッチモードの時は視点を親に移す */
	setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, -1
	if (GetWatchModeFlag(GameEnv) == 1) {
		setPlayer GameStat, getRound(GameStat)\NUM_OF_PLAYERS
	}
	/* 破回八連荘の後始末 */
	if (getAgariChain(GameStat) == -1) {setAgariChain GameStat, 1}
	/* 半荘の初期化と配牌を行なう */
	gosub *tableinit
	/* デバッグ用のコード(バグ検証のときを除いてコメントアウトしておくこと！) */
//	tmpTiles = 04,05,06,08,08,12,13,14,14,15,16,26,28
//	repeat 13: setHand GameStat, 0, cnt, (getPlayer(GameStat)+3)\4, tmpTiles(cnt): loop
//	tmpTiles = 04,04,06,07,08,16,17,18,26,26,27,28,28
//	repeat 13: setHand GameStat, 0, cnt, (getPlayer(GameStat)+1)\4, tmpTiles(cnt): loop
//	setHand GameStat, 0, 0, (getPlayer(GameStat))\4, 27
//	tmpTiles = 12,12,12,13,14,15,16,17,17,17,36,36,36
//	repeat 13: setHand GameStat, 0, cnt, (getPlayer(GameStat))\4, tmpTiles(cnt): loop
	/* 配牌終了時の処理 */
	repeat NUM_OF_PLAYERS: setHandStat GameStat, cnt, 0:lipai GameStat, cnt: loop
	setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, getRound(GameStat)\NUM_OF_PLAYERS // 最初に親から捨牌を行なう
	info "配牌を完了しました。"
	/* 摸打ループ */
	repeat
		info strf("プレイヤー [%d] のツモ番です。", getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))
		/* 変数の初期化 */
		calcdoukasen GameStat // 導火線の位置を更新
		if (getKangFlag(GameStat, KANG_FLAG) == 0) { setKangFlag GameStat, KANG_CHAINFLAG, 0: setKangFlag GameStat, KANG_TOPFLAG, 0 /* 連続槓の回数と頭槓和フラグをリセット */ }
		setCurrentDiscard GameStat, CURRENTDISCARD_TILECODE, 0
		/* ウォッチモードの時は視点をツモ番の人に移す */
		if (GetWatchModeFlag(GameEnv) == 1) {
			setPlayer GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
		}
		/* 再描画 */
		redrscreen
		/* 摸打の処理 */
		getdahai GameStat, GameEnv
		DiscardTileIndex = stat
		if (DiscardTileIndex == DAHAI_TYPE_DISCONNECT) {break}
		/* ウェイトを入れる */
//		if (((getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE) != getPlayer(GameStat))&&(IsRemotePlayer(GameEnv, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0))||(GetWatchModeFlag(GameEnv) == 1)) {
//			await 700
//		} else {
			await 0
//		}
		procdahai GameStat, GameEnv, DiscardTileIndex
		if (stat >= 0) {RoundEndType = stat: break}
		if (stat == -2) {continue getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)}
		await 80
		/* 栄和の処理 */
		gosub *ronhuproc // 栄和の処理
		await 0
		if ((RoundEndType = ENDKYOKU_TRIPLERON)||(RoundEndType = ENDKYOKU_DISCONNECT)) {break}
		if (RonPlayers(GameStat) > 0) {break}
		/* 四開槓なら流す */
		if (getRule(RULE_FOUR_KONG_RYUUKYOKU) != 2) {
			if ((getTotalKang(GameStat) == 4)&&(getNumberOfQuads(GameStat, 0) < 4)&&(getNumberOfQuads(GameStat, 1) < 4)&&(getNumberOfQuads(GameStat, 2) < 4)&&(getNumberOfQuads(GameStat, 3) < 4)) {
				RoundEndType = ENDKYOKU_SUUKAIKAN
				redrscreen: break
			}
		}
#ifdef ALLSANMA
		// 三人立直の判定
		if (getRule(RULE_FOUR_RIICHI_RYUUKYOKU) != 0) {
#ifdef SANMA4
			if (((getRichiFlag(GameStat, RICHI_FLAG, 0) != RIICHI_NO)||(playerwind(0, getRound(GameStat)) == PLAYER_NORTH))&&((getRichiFlag(GameStat, RICHI_FLAG, 1) != RIICHI_NO)||(playerwind(1, getRound(GameStat)) == PLAYER_NORTH))&&((getRichiFlag(GameStat, RICHI_FLAG, 2) != RIICHI_NO)||(playerwind(2, getRound(GameStat)) == PLAYER_NORTH))&&((getRichiFlag(GameStat, RICHI_FLAG, 3) != RIICHI_NO)||(playerwind(3, getRound(GameStat)) == PLAYER_NORTH))) {
#else
			if ((getRichiFlag(GameStat, RICHI_FLAG, 0)*getRichiFlag(GameStat, RICHI_FLAG, 1)*getRichiFlag(GameStat, RICHI_FLAG, 2)) != 0) {
#endif
				RoundEndType = ENDKYOKU_SUUCHARIICHI: break
			}
		}
		// 三風連打の判定
		if (getRule(RULE_FOUR_WIND_RYUUKYOKU) != 0) {
#ifdef SANMA4
			if (((DiscardPointer(GameStat, 0) == 1)||(playerwind(0, getRound(GameStat)) == PLAYER_NORTH))&&((DiscardPointer(GameStat, 1) == 1)||(playerwind(1, getRound(GameStat)) == PLAYER_NORTH))&&((DiscardPointer(GameStat, 2) == 1)||(playerwind(2, getRound(GameStat)) == PLAYER_NORTH))&&((DiscardPointer(GameStat, 3) == 1)||(playerwind(3, getRound(GameStat)) == PLAYER_NORTH))) {
				if (((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) == getDiscard(GameStat, DISCARD_TILECODE, 1, 1))||(playerwind(1, getRound(GameStat)) == PLAYER_NORTH))&&((getDiscard(GameStat, DISCARD_TILECODE, 1, 1) == getDiscard(GameStat, DISCARD_TILECODE, 1, 2))||(playerwind(2, getRound(GameStat)) == PLAYER_NORTH))&&((getDiscard(GameStat, DISCARD_TILECODE, 1, 2) == getDiscard(GameStat, DISCARD_TILECODE, 1, 3))||(playerwind(3, getRound(GameStat)) == PLAYER_NORTH))&&((getDiscard(GameStat, DISCARD_TILECODE, 1, 3) == getDiscard(GameStat, DISCARD_TILECODE, 1, 0))||(playerwind(0, getRound(GameStat)) == PLAYER_NORTH))) {
#else
			if ((DiscardPointer(GameStat, 0) == 1)&&(DiscardPointer(GameStat, 1) == 1)&&(DiscardPointer(GameStat, 2) == 1)) {
				if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) == getDiscard(GameStat, DISCARD_TILECODE, 1, 1))&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 1) == getDiscard(GameStat, DISCARD_TILECODE, 1, 2))) {
#endif
					if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) >= TILE_WIND_MIN)&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 0) <= TILE_WIND_MAX)) {
						RoundEndType = ENDKYOKU_SUUFONRENDA: break
					}
				}
			}
		}
#else
		// 四人立直の判定
		if (((getRichiFlag(GameStat, RICHI_FLAG, 0)*getRichiFlag(GameStat, RICHI_FLAG, 1)*getRichiFlag(GameStat, RICHI_FLAG, 2)*getRichiFlag(GameStat, RICHI_FLAG, 3)) != 0)&&(getRule(RULE_FOUR_RIICHI_RYUUKYOKU) != 2)) {
			RoundEndType = ENDKYOKU_SUUCHARIICHI: break
		}
		// 四風連打の判定
		if (getRule(RULE_FOUR_WIND_RYUUKYOKU) != 2) {
			if ((DiscardPointer(GameStat, 0) == 1)&&(DiscardPointer(GameStat, 1) == 1)&&(DiscardPointer(GameStat, 2) == 1)&&(DiscardPointer(GameStat, 3) == 1)) {
				if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) == getDiscard(GameStat, DISCARD_TILECODE, 1, 1))&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 1) == getDiscard(GameStat, DISCARD_TILECODE, 1, 2))&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 2) == getDiscard(GameStat, DISCARD_TILECODE, 1, 3))) {
					if ((getDiscard(GameStat, DISCARD_TILECODE, 1, 0) >= TILE_WIND_MIN)&&(getDiscard(GameStat, DISCARD_TILECODE, 1, 0) <= TILE_WIND_MAX)) {
						RoundEndType = ENDKYOKU_SUUFONRENDA: break
					}
				}
			}
		}
#endif
		repeat NUM_OF_PLAYERS: setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, cnt, 0: loop // バグ防止のため
		if (((getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE) == getPreviousMeld(GameStat, PREVMELD_TILECODE))||(getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE) == getPreviousMeld(GameStat, PREVMELD_STEPPED)))&&(getAgariHouki(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0)) {
			// 喰い替えの場合の処理
			switch getRule(RULE_KUIKAE)
				case 0: case 3:
					/* 和了り放棄とする設定 */
					info strf("喰い変えを検出しました。和了り放棄として扱います。打牌 [%d] 鳴いた牌 [%d]", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), getPreviousMeld(GameStat, PREVMELD_TILECODE))
					dsplay SND_CUOHU
					repeat 2
						setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "喰替"
						redrscreen: await 1500
						setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "和了放棄"
						redrscreen: await 1500
					loop
					setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), ""
					redrscreen
					/* 和了り放棄は以降強制ツモ切り、強制不聴扱いとなります */
					setAgariHouki GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 1
					if (GetWatchModeFlag(GameEnv) == 0) {statmes "和了り放棄：強制ツモ切りされます"}
					vanish: commonswitch GameStat, GameEnv
					swbreak
				case 1: case 4:
					/* 直ちに錯和とする設定 */
					info strf("喰い変えを検出しました。チョンボとして扱います。打牌 [%d] 鳴いた牌 [%d]", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), getPreviousMeld(GameStat, PREVMELD_TILECODE))
					dsplay SND_CUOHU
					RoundEndType = ENDKYOKU_CHONBO: setTsumoAgariFlag GameStat, AGARI_KUIKAE
					setCurrentPlayer GameStat, CURRENTPLAYER_AGARI, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
					setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "錯和"
					redrscreen: await 1500
					/* 局を打ち切り、満貫罰符の支払いに進む */
					break
			swend
		}
		/* 多牌や少牌をしていないかのチェック */
		tmptilecnt = 0
		repeat NUM_OF_TILES_IN_HAND
			if (getHand(GameStat, HAND_TILECODE, cnt, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) > 0) {tmptilecnt++}
		loop
		tmptilecnt += (MeldPointer(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) * 3)
		if ((tmptilecnt != (NUM_OF_TILES_IN_HAND-1))&&(getAgariHouki(GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0)) {
//			多牌や少牌の場合の処理(通常起きることはないはずだが…)
			if (tmptilecnt > (NUM_OF_TILES_IN_HAND-1)) {
				warn "多牌を検出しました。和了り放棄として扱いますが、摸打の処理で不整合が起きていた可能性があります。"
			} else {
				warn "少牌を検出しました。和了り放棄として扱いますが、摸打の処理で不整合が起きていた可能性があります。"
			}
			dsplay SND_CUOHU
			repeat 2
				if (tmptilecnt > (NUM_OF_TILES_IN_HAND-1)) {
					setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "多牌"
				} else {
					setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "少牌"
				}
				redrscreen: await 1500
				setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), "和了放棄"
				redrscreen: await 1500
			loop
			setCall getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), ""
			redrscreen
			setAgariHouki GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), 1
			if (GetWatchModeFlag(GameEnv) == 0) {statmes "和了り放棄：強制ツモ切りされます"}
			vanish: commonswitch GameStat, GameEnv
		}
		await 0
		/* 荒牌の場合ここで終了する(河底牌は吃ポンできないがロンはできる) */
		if (getDrawPointer(GameStat) == (getRinshanPointer(GameStat) - (getDeadWallLength(GameStat)-1))) {RoundEndType = ENDKYOKU_RYUUKYOKU: break}
		/* 捨牌をポン、または大明槓する場合の処理 */
		/* 同じ牌は４枚しかないので、ポンと明槓は同時に起こることがない */
		if (getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 3)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 3) > 1) {
			error "複数同時のポン・槓が宣言されています。"
		}
		repeat NUM_OF_PLAYERS: await 0
			/* 捨牌をポンする場合 */
			if (getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, cnt) == 1) {
				setCurrentPlayer GameStat, CURRENTPLAYER_PASSIVE, cnt // 鳴いたプレイヤーを設定
				fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_PON
				break
			}
			/* 明槓の場合 */
			if ((getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, cnt) == 1)&&(getTotalKang(GameStat) < (4+getRule(RULE_FIFTH_KONG)))) {
				setCurrentPlayer GameStat, CURRENTPLAYER_PASSIVE, cnt // 鳴いたプレイヤーを設定
				fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_DAIMINKAN
				break
			}
		loop
		/* 鳴きがあった場合、鳴いたプレーヤーに順番を移して戻る */
		/* 吃とポンが同時に起こった場合、ポンを優先する */
		if ((getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 3)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 3)) > 0) {
			setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, getCurrentPlayer(GameStat, CURRENTPLAYER_PASSIVE)
			continue
#ifndef ALLSANMA
		} else {
			/* 吃の処理 */
			/* 三人打ちでは吃なし */
			if (getDeclarationFlag(GameStat, DECLARATIONFLAG_CHI, ShimochaOf(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))) > 0) {
				setCurrentPlayer GameStat, CURRENTPLAYER_PASSIVE, ShimochaOf(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) // 吃ができるのは上家の捨牌のみ
				fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_CHII
				setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, getCurrentPlayer(GameStat, CURRENTPLAYER_PASSIVE)
				continue
			}
#endif
		}
		/* ウェイトを入れる */
		await 100
		/* バグ防止のアレ */
		repeat NUM_OF_PLAYERS: setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, cnt, 0: loop
		/* 次のプレイヤーが牌を自摸る */
		incDrawPointer GameStat: setHeavenHandFlag GameStat, 0
#ifdef SANMAT
		setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)+1)\NUM_OF_ACTUAL_PLAYERS
#else
#ifdef SANMA4
		/* 北家をスキップ */
		if (playerWind(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getRound(GameStat)) == PLAYER_WEST) {
			setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)+1)\NUM_OF_PLAYERS
		}
#endif
		setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)+1)\NUM_OF_PLAYERS
#endif
		setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getWall(GameStat, WALL_TILECODE, getDrawPointer(GameStat))
		setHand GameStat, HAND_REDTILE, TSUMOHAI_INDEX, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getWall(GameStat, WALL_REDTILE, getDrawPointer(GameStat))
		setPreviousMeld GameStat, PREVMELD_TILECODE, -999
		setPreviousMeld GameStat, PREVMELD_STEPPED, -999
		dsplay SND_TSUMO
		if (tilesLeft(GameStat) < 10) {
			dsplay SND_COUNTDOWN
		}
		// 打牌へ戻る
	loop
	OrigHonba = getHonba(GameStat): OrigTurn = getRound(GameStat)
	endround GameStat, GameEnv, RoundEndType, yakuInfo, OrigTurn, OrigHonba
	await 5000
	// ハコ割れ終了
	if (getRule(RULE_BUTTOBI_BORDER) != 2) {
		if (isDobon(GameStat,PLAYER_EAST)) {break}
		if (isDobon(GameStat,PLAYER_SOUTH)) {break}
		if (isDobon(GameStat,PLAYER_WEST)) {break}
#ifndef SANMAT
		if (isDobon(GameStat,PLAYER_NORTH)) {break}
#endif
	}
	// 和了り止め
	if (getRule(RULE_AGARIYAME) != 1) {
		if (((getRound(GameStat)+(getRoundLoop(GameStat)*16)) == getGameLength(GameStat))&&((OrigTurn+(getRoundLoop(GameStat)*16)) == getGameLength(GameStat))&&((RoundEndType == ENDKYOKU_AGARI)||(getRule(RULE_AGARIYAME) == 2))) {
			calcRank Rank, GameStat
			if ((Rank(getRound(GameStat)\NUM_OF_PLAYERS) == 1)&&(getScore(GameStat,getRound(GameStat)\NUM_OF_PLAYERS) >= BasePoint())) {break}
		}
	}
#ifdef SANMAT
	if (getRound(GameStat)\NUM_OF_PLAYERS == 3) {incRound GameStat}
#endif
	// 東北廻しのとき
	if ((getRound(GameStat) == 4)&&(getRule(RULE_GAME_LENGTH) == 3)) {setRound GameStat, 12}
	// 東々廻しのとき
	if ((getRound(GameStat) == 4)&&((getRule(RULE_GAME_LENGTH) == 5)||(getRule(RULE_GAME_LENGTH) == 7))) {setRound GameStat, 16}
	// 通常の半荘終了時（トップが３００００点未満だと西入サドンデス）
#ifdef SANMAT
	if ((((getRound(GameStat)+(getRoundLoop(GameStat)*16)) >= (getGameLength(GameStat)+1)))&&((getScore(GameStat,0) >= BasePoint())||(getScore(GameStat,1) >= BasePoint())||(getScore(GameStat,2) >= BasePoint()))) {break}
#else
	if ((((getRound(GameStat)+(getRoundLoop(GameStat)*16)) >= (getGameLength(GameStat)+1)))&&((getScore(GameStat,0) >= BasePoint())||(getScore(GameStat,1) >= BasePoint())||(getScore(GameStat,2) >= BasePoint())||(getScore(GameStat,3) >= BasePoint()))) {break}
#endif
	// 北場終了の場合は帰り東へ
	if (getRound(GameStat) == 16) {incRoundLoop GameStat: setRound GameStat, 0}
loop
// 半荘終了時
#include "hancnend.hsp"
stop
