/*=============================
 * HSP麻雀クライアントMiHaJong
 *      [メインルーチン]
 *=============================
 */

/* ゲーム開始処理 */
*startgame
	/* 変数類の初期化 */
	TableEnvInit GameEnv
	if (vartype(GameStat) == vartype("struct")) {
		if (varuse(GameStat)) {
			delmod GameStat
		}
	}
	newmod GameStat, gameStruct
	vanish
	info "ゲーム情報を初期化しました。"
	serverreceive_init
	bgmplay MUS_TITLE	// タイトル曲を流す
	gosub *selmode	// タイトル画面
	gosub *chrshuffle	// 親決めの処理
	gosub *gameinit	// 半荘の初期化処理
	font fontname, 18, 1

/* 半荘の進行 */
repeat
	info strf("局番号 [%d] を開始しました。", getRound(GameStat))
	if (getGameMode(GameEnv) == GAMEMODE_CLIENT) {
		sockput "8\n", SOCK_CHAT+0 // チャットを同期
	}
	/* ウォッチモードの時は視点を親に移す */
	setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, -1
	if (GetWatchModeFlag(GameEnv) == 1) {
		setPlayer GameStat, getRound(GameStat)\NUM_OF_PLAYERS
	}
	/* 破回八連荘の後始末 */
	if (getAgariChain(GameStat) == -1) {setAgariChain GameStat, 1}
	/* 半荘の初期化と配牌を行なう */
	gosub *tableinit
	/* デバッグ用のコード(バグ検証のときを除いてコメントアウトしておくこと！) */
//	tmpTiles = 04,05,06,08,08,12,13,14,14,15,16,26,28
//	repeat 13: setHand GameStat, 0, cnt, (getPlayer(GameStat)+3)\4, tmpTiles(cnt): loop
//	tmpTiles = 04,04,06,07,08,16,17,18,26,26,27,28,28
//	repeat 13: setHand GameStat, 0, cnt, (getPlayer(GameStat)+1)\4, tmpTiles(cnt): loop
//	setHand GameStat, 0, 0, (getPlayer(GameStat))\4, 27
//	tmpTiles = 12,12,12,13,14,15,16,17,17,17,36,36,36
//	tmpTiles = 31,31,31,32,32,32,33,33,33,34,34,34,35
//	repeat 13: setHand GameStat, 0, cnt, (getPlayer(GameStat))\4, tmpTiles(cnt): loop
	/* 配牌終了時の処理 */
	repeat NUM_OF_PLAYERS: setHandStat GameStat, cnt, 0:lipai GameStat, cnt: loop
	setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, getRound(GameStat)\NUM_OF_PLAYERS // 最初に親から捨牌を行なう
	info "配牌を完了しました。"
	/* 摸打ループ */
	repeat
		info strf("プレイヤー [%d] のツモ番です。", getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))
		/* 変数の初期化 */
		calcdoukasen GameStat // 導火線の位置を更新
		if (getKangFlag(GameStat, KANG_FLAG) == 0) { setKangFlag GameStat, KANG_CHAINFLAG, 0: setKangFlag GameStat, KANG_TOPFLAG, 0 /* 連続槓の回数と頭槓和フラグをリセット */ }
		setCurrentDiscard GameStat, CURRENTDISCARD_TILECODE, 0
		/* ウォッチモードの時は視点をツモ番の人に移す */
		if (GetWatchModeFlag(GameEnv) == 1) {
			setPlayer GameStat, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)
		}
		/* 再描画 */
		redrscreen
		/* 摸打の処理 */
		getdahai GameStat, GameEnv
		DiscardTileIndex = stat
		if (DiscardTileIndex == DAHAI_TYPE_DISCONNECT) {break}
		/* ウェイトを入れる */
//		if (((getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE) != getPlayer(GameStat))&&(IsRemotePlayer(GameEnv, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) == 0))||(GetWatchModeFlag(GameEnv) == 1)) {
//			await 700
//		} else {
			await 0
//		}
		procdahai GameStat, GameEnv, DiscardTileIndex, yakuInfo
		if (stat >= 0) {RoundEndType = stat: break}
		if (stat == -2) {continue getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)}
		await 80
		/* 栄和の処理 */
		gosub *ronhuproc // 栄和の処理
		await 0
		if ((RoundEndType = ENDKYOKU_TRIPLERON)||(RoundEndType = ENDKYOKU_DISCONNECT)) {break}
		if (RonPlayers(GameStat) > 0) {break}
		/* 途中流局の判定 */
		checkroundabort GameStat, GameEnv
		if (stat >= 0) {RoundEndType = stat: break}
		/* 捨牌をポン、または大明槓する場合の処理 */
		/* 同じ牌は４枚しかないので、ポンと明槓は同時に起こることがない */
		if (getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 3)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 3) > 1) {
			error "複数同時のポン・槓が宣言されています。"
		}
		repeat NUM_OF_PLAYERS: await 0
			/* 捨牌をポンする場合 */
			if (getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, cnt) == 1) {
				setCurrentPlayer GameStat, CURRENTPLAYER_PASSIVE, cnt // 鳴いたプレイヤーを設定
				fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_PON
				break
			}
			/* 明槓の場合 */
			if ((getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, cnt) == 1)&&(getTotalKang(GameStat) < (4+getRule(RULE_FIFTH_KONG)))) {
				setCurrentPlayer GameStat, CURRENTPLAYER_PASSIVE, cnt // 鳴いたプレイヤーを設定
				fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_DAIMINKAN
				break
			}
		loop
		/* 鳴きがあった場合、鳴いたプレーヤーに順番を移して戻る */
		/* 吃とポンが同時に起こった場合、ポンを優先する */
		if ((getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 3)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 0)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 1)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 2)+getDeclarationFlag(GameStat, DECLARATIONFLAG_MINKAN, 3)) > 0) {
			setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, getCurrentPlayer(GameStat, CURRENTPLAYER_PASSIVE)
			continue
#ifndef ALLSANMA
		} else {
			/* 吃の処理 */
			/* 三人打ちでは吃なし */
			if (getDeclarationFlag(GameStat, DECLARATIONFLAG_CHI, ShimochaOf(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE))) > 0) {
				setCurrentPlayer GameStat, CURRENTPLAYER_PASSIVE, ShimochaOf(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)) // 吃ができるのは上家の捨牌のみ
				fuuroproc GameStat, RoundEndType, DiscardTileIndex, FUURO_CHII
				setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, getCurrentPlayer(GameStat, CURRENTPLAYER_PASSIVE)
				continue
			}
#endif
		}
		/* ウェイトを入れる */
		await 100
		/* バグ防止のアレ */
		repeat NUM_OF_PLAYERS: setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, cnt, 0: loop
		/* 次のプレイヤーが牌を自摸る */
		incDrawPointer GameStat: setHeavenHandFlag GameStat, 0
#ifdef SANMAT
		setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)+1)\NUM_OF_ACTUAL_PLAYERS
#else
#ifdef SANMA4
		/* 北家をスキップ */
		if (playerWind(getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getRound(GameStat)) == PLAYER_WEST) {
			setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)+1)\NUM_OF_PLAYERS
		}
#endif
		setCurrentPlayer GameStat, CURRENTPLAYER_ACTIVE, (getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE)+1)\NUM_OF_PLAYERS
#endif
		setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getWall(GameStat, WALL_TILECODE, getDrawPointer(GameStat))
		setHand GameStat, HAND_REDTILE, TSUMOHAI_INDEX, getCurrentPlayer(GameStat, CURRENTPLAYER_ACTIVE), getWall(GameStat, WALL_REDTILE, getDrawPointer(GameStat))
		setPreviousMeld GameStat, PREVMELD_TILECODE, -999
		setPreviousMeld GameStat, PREVMELD_STEPPED, -999
		dsplay SND_TSUMO
		if (tilesLeft(GameStat) < 10) {
			dsplay SND_COUNTDOWN
		}
		// 打牌へ戻る
	loop
	OrigHonba = getHonba(GameStat): OrigTurn = getRound(GameStat)
	endround GameStat, GameEnv, RoundEndType, yakuInfo, OrigTurn, OrigHonba
	await 5000
	// ハコ割れ終了
	if (getRule(RULE_BUTTOBI_BORDER) != 2) {
		if (isDobon(GameStat,PLAYER_EAST)) {break}
		if (isDobon(GameStat,PLAYER_SOUTH)) {break}
		if (isDobon(GameStat,PLAYER_WEST)) {break}
#ifndef SANMAT
		if (isDobon(GameStat,PLAYER_NORTH)) {break}
#endif
	}
	// 和了り止め
	if (getRule(RULE_AGARIYAME) != 1) {
		if (((getRound(GameStat)+(getRoundLoop(GameStat)*16)) == getGameLength(GameStat))&&((OrigTurn+(getRoundLoop(GameStat)*16)) == getGameLength(GameStat))&&((RoundEndType == ENDKYOKU_AGARI)||(getRule(RULE_AGARIYAME) == 2))) {
			calcRank Rank, GameStat
			if ((Rank(getRound(GameStat)\NUM_OF_PLAYERS) == 1)&&(getScore(GameStat,getRound(GameStat)\NUM_OF_PLAYERS) >= BasePoint())) {break}
		}
	}
#ifdef SANMAT
	if (getRound(GameStat)\NUM_OF_PLAYERS == 3) {incRound GameStat}
#endif
	// 東北廻しのとき
	if ((getRound(GameStat) == 4)&&(getRule(RULE_GAME_LENGTH) == 3)) {setRound GameStat, 12}
	// 東々廻しのとき
	if ((getRound(GameStat) == 4)&&((getRule(RULE_GAME_LENGTH) == 5)||(getRule(RULE_GAME_LENGTH) == 7))) {setRound GameStat, 16}
	// 通常の半荘終了時（トップが３００００点未満だと西入サドンデス）
#ifdef SANMAT
	if ((((getRound(GameStat)+(getRoundLoop(GameStat)*16)) >= (getGameLength(GameStat)+1)))&&((getScore(GameStat,0) >= BasePoint())||(getScore(GameStat,1) >= BasePoint())||(getScore(GameStat,2) >= BasePoint()))) {break}
#else
	if ((((getRound(GameStat)+(getRoundLoop(GameStat)*16)) >= (getGameLength(GameStat)+1)))&&((getScore(GameStat,0) >= BasePoint())||(getScore(GameStat,1) >= BasePoint())||(getScore(GameStat,2) >= BasePoint())||(getScore(GameStat,3) >= BasePoint()))) {break}
#endif
	// 北場終了の場合は帰り東へ
	if (getRound(GameStat) == 16) {incRoundLoop GameStat: setRound GameStat, 0}
loop
// 半荘終了時
#include "hancnend.hsp"
stop
