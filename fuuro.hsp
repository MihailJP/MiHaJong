/*=============================
 * HSP麻雀クライアントMiHaJong
 *     [副露処理ルーチン]
 *=============================
 */

/* 副露の処理 */
#module
#include "const.as"
#deffunc fuuroproc var GameStat, array ChiFlag, var RoundEndType, int DiscardTileIndex, int ActivePlayer, int PassivePlayer, int Mode
	info strf("副露の処理を開始します。モード [%d]", Mode)
	switch Mode
		case FUURO_CHII:
			kangPlayer = PassivePlayer
			setMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, kangPlayer)+1, kangPlayer, 0 // 赤ドラバグ回避のため
			haifurecchi GameStat, PassivePlayer // 牌譜に記録
			swbreak
		case FUURO_PON:
			kangPlayer = PassivePlayer
			setMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, kangPlayer)+1, kangPlayer, 0 // 赤ドラバグ回避のため
			haifurecpon GameStat, PassivePlayer, ActivePlayer // 牌譜に記録
			swbreak
#ifndef SANMAX
		case FUURO_FLOWER:
			kangPlayer = ActivePlayer
			setKangFlag GameStat, KANG_FLAG, 1 // 嶺上開花のフラグを立てる
			haifurecflower GameStat, kangPlayer, DiscardTileIndex
			swbreak
#else
		case FUURO_NORTH:
			kangPlayer = ActivePlayer
			setKangFlag GameStat, KANG_FLAG, 1 // 嶺上開花のフラグを立てる
			haifurecnorth GameStat, kangPlayer, DiscardTileIndex
			swbreak
#endif
		case FUURO_DAIMINKAN:
			kangPlayer = PassivePlayer
			setKangFlag GameStat, KANG_FLAG, 1 // 嶺上開花のフラグを立てる
			setMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, kangPlayer)+1, kangPlayer, 0 // 赤ドラバグ回避のため
			haifurecminkan GameStat, PassivePlayer, ActivePlayer // 牌譜に記録
			incKangFlag GameStat, KANG_CHAINFLAG // 連続槓の回数を記録
			if (getFirstDrawFlag(GameStat, kangPlayer) == 1) { setKangFlag GameStat, KANG_TOPFLAG, 1 /* 頭槓和のフラグ */ }
			swbreak
		default:
			kangPlayer = ActivePlayer
			setKangFlag GameStat, KANG_FLAG, 1 // 嶺上開花のフラグを立てる
			setMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, kangPlayer)+1, kangPlayer, 0 // 赤ドラバグ回避のため
			haifurecankan GameStat, kangPlayer, DiscardTileIndex // 暗槓を仮に牌譜に記録
			incKangFlag GameStat, KANG_CHAINFLAG // 連続槓の回数を記録
			if (getFirstDrawFlag(GameStat, kangPlayer) == 1) { setKangFlag GameStat, KANG_TOPFLAG, 1 /* 頭槓和のフラグ */ }
	swend
	/* カンする牌を設定 */
	if (Mode != FUURO_PON)&&(Mode != FUURO_CHII)&&(Mode != FUURO_DAIMINKAN) {
		setCurrentDiscard GameStat, CURRENTDISCARD_TILECODE, getHand(GameStat, HAND_TILECODE, DiscardTileIndex\DAHAI_TYPE_STEP, kangPlayer)
		setCurrentDiscard GameStat, CURRENTDISCARD_REDTILE, getHand(GameStat, HAND_REDTILE, DiscardTileIndex\DAHAI_TYPE_STEP, kangPlayer)
	}
	/* 暗槓・加槓を実行する */
	nakiCount = 0
	switch Mode
		case FUURO_ANKAN: /* 暗槓 */
			MeldPointerIncrement GameStat, kangPlayer
			setMeld GameStat, MELD_TILECODE, MeldPointer(GameStat, kangPlayer), kangPlayer, MELD_QUAD_CONCEALED*MELD_TYPE_STEP+getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
			repeat NUM_OF_TILES_IN_HAND
				if (getHand(GameStat, HAND_TILECODE, cnt, kangPlayer) == getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)) {
					if (nakiCount == 0) {
						switch getHand(GameStat, HAND_REDTILE, cnt, PassivePlayer)
							case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x08: swbreak
							case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x80: swbreak
						swend
					}
					if (nakiCount == 1) {
						switch getHand(GameStat, HAND_REDTILE, cnt, PassivePlayer)
							case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x04: swbreak
							case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x40: swbreak
						swend
					}
					if (nakiCount == 2) {
						switch getHand(GameStat, HAND_REDTILE, cnt, PassivePlayer)
							case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x02: swbreak
							case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x20: swbreak
						swend
					}
					if (nakiCount == 3) {
						switch getHand(GameStat, HAND_REDTILE, cnt, PassivePlayer)
							case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x01: swbreak
							case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x10: swbreak
						swend
					}
					setHand GameStat, HAND_TILECODE, cnt, kangPlayer, 0
					setHand GameStat, HAND_REDTILE, cnt, kangPlayer, 0
					nakiCount++
				}
			loop
			if (nakiCount < 4) {error strf("暗槓するための牌が足りません。牌コード [%d] は [%d] 枚しかありません。", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), nakiCount)}
			if (nakiCount > 4) {error strf("暗槓するための牌が多すぎます。牌コード [%d] は [%d] 枚あります。", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), nakiCount)}
			swbreak
		case FUURO_KAKAN: /* 加槓 */
			repeat MeldPointer(GameStat, kangPlayer), 1
				if (getMeld(GameStat, MELD_TILECODE, cnt, kangPlayer)\TILE_CODE_MAXIMUM == getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)) {
					if ((getMeld(GameStat, MELD_TILECODE, cnt, kangPlayer)/MELD_TYPE_STEP >= MELD_TRIPLET_EXPOSED_MIN)&&(getMeld(GameStat, MELD_TILECODE, cnt, kangPlayer)/MELD_TYPE_STEP <= MELD_TRIPLET_EXPOSED_MAX)) {
						flagMeld GameStat, MELD_TILECODE, cnt, kangPlayer, (MELD_QUAD_ADDED_LEFT-MELD_TRIPLET_EXPOSED_LEFT)*MELD_TYPE_STEP
						switch getCurrentDiscard(GameStat, CURRENTDISCARD_REDTILE)
							case 1: flagMeld GameStat, MELD_REDTILE, cnt, kangPlayer, 0x08: swbreak
							case 2: flagMeld GameStat, MELD_REDTILE, cnt, kangPlayer, 0x80: swbreak
						swend
						nakiCount++
					}
				}
			loop
			setHand GameStat, HAND_TILECODE, DiscardTileIndex\DAHAI_TYPE_STEP, kangPlayer, 0
			setHand GameStat, HAND_REDTILE, DiscardTileIndex\DAHAI_TYPE_STEP, kangPlayer, 0
			if (nakiCount == 0) {error strf("加槓するための明刻子が見つかりません。牌コード [%d]", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE))}
			if (nakiCount > 1) {error strf("加槓するための明刻子が複数見つかりました。面子データに不整合が発生しています。牌コード [%d]", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE))}
			swbreak
		case FUURO_DAIMINKAN: /* 大明槓 */
			repeat NUM_OF_TILES_IN_HAND
				if ((getHand(GameStat, HAND_TILECODE, cnt, PassivePlayer) == getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE))&&(nakiCount < 3)) {
					// 鳴いた牌を純手牌から消去
					if (nakiCount == 0) {
						switch getHand(GameStat, HAND_REDTILE, cnt, PassivePlayer)
							case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x02: swbreak
							case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x20: swbreak
						swend
					}
					if (nakiCount == 1) {
						switch getHand(GameStat, HAND_REDTILE, cnt, PassivePlayer)
							case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x04: swbreak
							case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x40: swbreak
						swend
					}
					if (nakiCount == 2) {
						switch getHand(GameStat, HAND_REDTILE, cnt, PassivePlayer)
							case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x08: swbreak
							case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x80: swbreak
						swend
					}
					setHand GameStat, HAND_TILECODE, cnt, PassivePlayer, 0
					setHand GameStat, HAND_REDTILE, cnt, PassivePlayer, 0
					nakiCount++
				}
			loop
			if (nakiCount < 3) {error strf("明槓するための牌が足りません。牌コード [%d] は [%d] 枚しかありません。", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), nakiCount)}
			if (nakiCount > 3) {error strf("明槓するための牌が多すぎます。牌コード [%d] は [%d] 枚あります。", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), nakiCount)}
			/* 門前清フラグを降ろす */
			setMenzen GameStat, PassivePlayer, 0
			/* 槓子として晒す */
			MeldPointerIncrement GameStat, PassivePlayer
			setMeld GameStat, MELD_TILECODE, MeldPointer(GameStat, PassivePlayer), PassivePlayer, (playerRelative(PassivePlayer, ActivePlayer)+MELD_QUAD)*MELD_TYPE_STEP+getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
			switch getCurrentDiscard(GameStat, CURRENTDISCARD_REDTILE)
				case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer), PassivePlayer, 0x01: swbreak
				case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer), PassivePlayer, 0x10: swbreak
			swend
			/* 理牌する */
			lipai GameStat, PassivePlayer
			swbreak
#ifdef SANMAX
		case FUURO_NORTH: /* 三麻抜きドラ */
			dsplay@ VOX_FLOWER
			addNorthFlag GameStat, kangPlayer
			setHand GameStat, HAND_TILECODE, DiscardTileIndex-DAHAI_TYPE_FLOWER, kangPlayer, 0
			setHand GameStat, HAND_REDTILE, DiscardTileIndex-DAHAI_TYPE_FLOWER, kangPlayer, 0
			setHeavenHandFlag GameStat, 0
			setCall kangPlayer, "北"
			lipai GameStat, kangPlayer
			repeat NUM_OF_PLAYERS
				setFirstDrawFlag GameStat, cnt, 0
			loop
			swbreak
#else
		case FUURO_FLOWER: /* 花牌 */
			dsplay@ VOX_FLOWER
			switch getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
				case TILE_SPRING: setFlowerFlag GameStat, kangPlayer, FLOWER_SPRING: swbreak
				case TILE_SUMMER: setFlowerFlag GameStat, kangPlayer, FLOWER_SUMMER: swbreak
				case TILE_AUTUMN: setFlowerFlag GameStat, kangPlayer, FLOWER_AUTUMN: swbreak
				case TILE_WINTER: setFlowerFlag GameStat, kangPlayer, FLOWER_WINTER: swbreak
				case TILE_PLUM: setFlowerFlag GameStat, kangPlayer, FLOWER_PLUM: swbreak
				case TILE_ORCHID: setFlowerFlag GameStat, kangPlayer, FLOWER_ORCHID: swbreak
				case TILE_CHRYSANTHEMUM: setFlowerFlag GameStat, kangPlayer, FLOWER_CHRYSANTHEMUM: swbreak
				case TILE_BAMBOO: setFlowerFlag GameStat, kangPlayer, FLOWER_BAMBOO: swbreak
				default
					warn strf("牌コード [%d] は花牌ではありません。", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE))
			swend
			setHand GameStat, HAND_TILECODE, DiscardTileIndex\DAHAI_TYPE_STEP, kangPlayer, 0
			setHand GameStat, HAND_REDTILE, DiscardTileIndex\DAHAI_TYPE_STEP, kangPlayer, 0
			setHeavenHandFlag GameStat, 0
			setCall ActivePlayer, "花"
			lipai GameStat, ActivePlayer
			repeat NUM_OF_PLAYERS
				setFirstDrawFlag GameStat, cnt, 0
			loop
			swbreak
#endif
		case FUURO_PON: /* ポン */
			/* ポンした対子を消去 */
			nakiCount = 0
			repeat NUM_OF_TILES_IN_HAND
				if ((getHand(GameStat, HAND_TILECODE, cnt, PassivePlayer) == getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE))&&(nakiCount < 2)) {
					// 鳴いた牌を純手牌から消去
					if (nakiCount == 0) {
						switch getHand(GameStat, HAND_REDTILE, cnt, PassivePlayer)
							case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x02: swbreak
							case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x20: swbreak
						swend
					}
					if (nakiCount == 1) {
						switch getHand(GameStat, HAND_REDTILE, cnt, PassivePlayer)
							case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x04: swbreak
							case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x40: swbreak
						swend
					}
					setHand GameStat, HAND_TILECODE, cnt, PassivePlayer, 0
					setHand GameStat, HAND_REDTILE, cnt, PassivePlayer, 0
					nakiCount++
				}
			loop
			if (nakiCount < 2) {error strf("ポンするための牌が足りません。牌コード [%d] は [%d] 枚しかありません。", getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE), nakiCount)}
			/* 門前清フラグを降ろす */
			setMenzen GameStat, cnt, 0
			/* 明刻として晒す */
			MeldPointerIncrement GameStat, cnt
			setMeld GameStat, MELD_TILECODE, MeldPointer(GameStat, cnt), cnt, (playerRelative(PassivePlayer, ActivePlayer)+MELD_TRIPLET)*MELD_TYPE_STEP+getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
			switch getCurrentDiscard(GameStat, CURRENTDISCARD_REDTILE)
				case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, cnt), cnt, 0x01: swbreak
				case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, cnt), cnt, 0x10: swbreak
			swend
			/* 理牌する */
			lipai GameStat, PassivePlayer
			/* ポンを宣言する */
			dsplay@ VOX_PON
			setCall PassivePlayer, "ポン"
			/* 喰い替えの判定に使う変数を設定 */
			setPreviousMeld GameStat, PREVMELD_TILECODE, getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
			setPreviousMeld GameStat, PREVMELD_STEPPED, -999
			/* 包の判定 */
			checkpao GameStat, PassivePlayer, ActivePlayer
			swbreak
#ifndef ALLSANMA
		case FUURO_CHII: /* チー */
			/* チーする牌を設定 */
			setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, PassivePlayer, getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
			setHand GameStat, HAND_REDTILE, TSUMOHAI_INDEX, PassivePlayer, getCurrentDiscard(GameStat, CURRENTDISCARD_REDTILE)
			/* 純手牌から鳴いた塔子を除去 */
			nakiCount1 = 0: nakiCount2 = 0: nakiCount3 = 0
			repeat NUM_OF_TILES_IN_HAND, TSUMOHAI_INDEX
				if ((getHand(GameStat, HAND_TILECODE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer) == getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)+1-ChiFlag(PassivePlayer))&&(nakiCount1 < 1)) {
					switch getHand(GameStat, HAND_REDTILE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer)
						case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x01: swbreak
						case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x10: swbreak
					swend
					setHand GameStat, HAND_TILECODE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer, 0
					setHand GameStat, HAND_REDTILE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer, 0
					nakiCount1++
				}
				if ((getHand(GameStat, HAND_TILECODE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer) == getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)+2-ChiFlag(PassivePlayer))&&(nakiCount2 < 1)) {
					switch getHand(GameStat, HAND_REDTILE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer)
						case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x02: swbreak
						case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x20: swbreak
					swend
					setHand GameStat, HAND_TILECODE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer, 0
					setHand GameStat, HAND_REDTILE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer, 0
					nakiCount2++
				}
				if ((getHand(GameStat, HAND_TILECODE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer) == getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)+3-ChiFlag(PassivePlayer))&&(nakiCount3 < 1)) {
					switch getHand(GameStat, HAND_REDTILE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer)
						case 1: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x04: swbreak
						case 2: flagMeld GameStat, MELD_REDTILE, MeldPointer(GameStat, PassivePlayer)+1, PassivePlayer, 0x40: swbreak
					swend
					setHand GameStat, HAND_TILECODE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer, 0
					setHand GameStat, HAND_REDTILE, (cnt\NUM_OF_TILES_IN_HAND), PassivePlayer, 0
					nakiCount3++
				}
			loop
			/* 門前フラグを降ろす */
			setMenzen GameStat, PassivePlayer, 0
			/* 順子を晒す */
			MeldPointerIncrement GameStat, PassivePlayer
			setMeld GameStat, MELD_TILECODE, MeldPointer(GameStat, PassivePlayer), PassivePlayer, ChiFlag(PassivePlayer)*MELD_TYPE_STEP+(getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)+1-ChiFlag(PassivePlayer))
			/* 自動理牌 */
			lipai GameStat, PassivePlayer
			/* チーを宣言 */
			dsplay@ VOX_CHI
			setCall PassivePlayer, "チー"
			/* 喰い替え判定用の変数を指定 */
			setPreviousMeld GameStat, PREVMELD_TILECODE, getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
			switch getRule(RULE_KUIKAE)
				case 1: case 2:
					switch (ChiFlag(PassivePlayer))
						case 1: setPreviousMeld GameStat, PREVMELD_STEPPED, getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)+3: swbreak
						case 2: setPreviousMeld GameStat, PREVMELD_STEPPED, -999: swbreak
						case 3: setPreviousMeld GameStat, PREVMELD_STEPPED, getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)-3: swbreak
					swend
					swbreak
				default:
					setPreviousMeld GameStat, PREVMELD_STEPPED, -999
			swend
			swbreak
#endif
		default:
			error strf("モードが正しくありません [%d]", Mode)
	swend
	if (Mode==FUURO_CHII)||(Mode==FUURO_PON)||(Mode==FUURO_DAIMINKAN) {
		/* 鳴いた捨牌を河で非表示にする */
		tmpSutehaiVar = (getDiscard(GameStat, DISCARD_TILECODE, DiscardPointer(GameStat, ActivePlayer), ActivePlayer)/SUTEHAI_TYPE_STEP)*SUTEHAI_TYPE_STEP
		switch tmpSutehaiVar
			case SUTEHAI_NORMAL: case SUTEHAI_RIICHI:
				flagDiscard GameStat, DiscardPointer(GameStat, ActivePlayer), ActivePlayer, (SUTEHAI_TAKEN-SUTEHAI_NORMAL)
				swbreak
		swend
	}
	/* カンを宣言、天和や地和のフラグが立っていれば降ろす */
	if (Mode==FUURO_ANKAN)||(Mode==FUURO_KAKAN)||(Mode==FUURO_DAIMINKAN) {
		setHeavenHandFlag GameStat, 0
		dsplay@ VOX_KAN
		setCall kangPlayer, "カン"
		lipai GameStat, kangPlayer
		repeat NUM_OF_PLAYERS
			setFirstDrawFlag GameStat, cnt, 0
		loop
	}
	redrscreen
	if (Mode != FUURO_DAIMINKAN)&&(Mode != FUURO_PON)&&(Mode != FUURO_CHII) {
		/* 国士無双に限り、暗槓を搶槓可能 */
		/* 断幺牌の暗槓は搶槓しようがないんですが、面倒なので区別せず処理
		   暗槓非開示設定の時は何を暗槓したか分からないので処理をスキップ*/
		/* 搶槓の判定 ここから */
		/* 搶槓の際の注意事項。元々のポンが自分の捨牌のものの場合
		   振聴となるので搶槓はできません */
		if ((Mode == FUURO_ANKAN)||(Mode == FUURO_KAKAN)||(Mode == FUURO_NORTH)) {
			if (Mode == FUURO_KAKAN)||(Mode == FUURO_NORTH)||((getRule(RULE_ANKAN_CONCEAL) == 0)&&(getRule(RULE_ANKAN_CHANKAN) == 0)) {
				debug "搶槓の判定をします。"
				if (Mode==FUURO_ANKAN) {setKangFlag GameStat, KANG_CHANKAN, 2} else {setKangFlag GameStat, KANG_CHANKAN, 1}
				gosub *ronhuproc@
				if (Mode == FUURO_NORTH) {setKangFlag GameStat, KANG_CHANKAN, 0}
				if ((RoundEndType = ENDKYOKU_TRIPLERON)||(RoundEndType = ENDKYOKU_DISCONNECT)) {return 1}
				if (RonPlayers(GameStat) > 0) {
					info "搶槓が宣言されました。ループから出ます。"
					return 1
				}
				setKangFlag GameStat, KANG_CHANKAN, 0
			}
		}
		/* 搶槓の判定 ここまで */
		debug "副露に成功しました。"
		switch Mode
			case FUURO_ANKAN: case FUURO_KAKAN:
				haifureckanproc kangPlayer // 搶槓が無い場合、牌譜に記録
				swbreak
#ifdef SANMAX
			case FUURO_NORTH:
				haifurecnorthproc kangPlayer
				swbreak
#endif
		swend
	}
	if (Mode == FUURO_DAIMINKAN) {
		/* バグ防止の為 */
		repeat NUM_OF_PLAYERS: setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, cnt, 0: loop
		repeat NUM_OF_PLAYERS: setHand GameStat, HAND_REDTILE, TSUMOHAI_INDEX, cnt, 0: loop
		/* 大明槓の包判定用 */
		if ((getRule(RULE_MINKAN_PAO) != 0)&&(getRule(RULE_MINKAN_PAO) != 3)) {
			setPao GameStat, PAO_PLAYER_PAO, PAO_YAKU_MINKAN, ActivePlayer
			setPao GameStat, PAO_PLAYER_AGARI, PAO_YAKU_MINKAN, PassivePlayer
		}
	}
	redrscreen
	await 1000
	if (Mode != FUURO_PON)&&(Mode != FUURO_CHII) {
		/* 四槓子の聴牌者がいて、５回目の槓があると流局とするルールの場合
		   その条件を判定する*/
		if (Mode==FUURO_ANKAN)||(Mode==FUURO_KAKAN)||(Mode==FUURO_DAIMINKAN) {
			if (getTotalKang(GameStat) >= 4) {
				debug "5個目の槓なので直ちに流局とし、ループから出ます。"
				RoundEndType = ENDKYOKU_UUKAIKAN: return 1
			}
		}
		if (getDrawPointer(GameStat) >= (getRinshanPointer(GameStat) - (getDeadWallLength(GameStat)-1))) {RoundEndType = ENDKYOKU_RYUUKYOKU: return 1 /* 荒牌なら終了 */}
		/* 嶺上牌を自摸る */
		setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, kangPlayer, getWall(GameStat, WALL_TILECODE, getRinshanPointer(GameStat))
		setHand GameStat, HAND_REDTILE, TSUMOHAI_INDEX, kangPlayer, getWall(GameStat, WALL_REDTILE, getRinshanPointer(GameStat))
		decRinshanPointer GameStat
		dsplay@ SND_TSUMO
		if (tilesLeft(GameStat) < 10) {
			dsplay@ SND_COUNTDOWN
		}
		if (Mode==FUURO_ANKAN)||(Mode==FUURO_KAKAN)||(Mode==FUURO_DAIMINKAN) {
			/* 槓ドラをめくる */
			if (getRule(RULE_KANDORA) != 1) {
				setDoraPointer GameStat, getDoraPointer(GameStat) - 2
				dsplay@ SND_MEKURI
				setdora GameStat, 0 // 表ドラを設定する
				if ((getRule(RULE_KANDORA) == 0)&&(getRule(RULE_URADORA) == 0)){
					setdora GameStat, 1 // 裏ドラを設定する
				}
				haifurecdorap
			}
			/* 包の判定 */
			checkpao GameStat, PassivePlayer, ActivePlayer
		}
		/* 槓子をカウントする(四開槓の判定のため) */
		if (Mode==FUURO_ANKAN)||(Mode==FUURO_KAKAN)||(Mode==FUURO_DAIMINKAN) {
			incNumberOfQuads GameStat, kangPlayer
			incTotalKang GameStat
			debug strf("プレイヤー [%d] が [%d] 回開槓、全員の合計で [%d] 回開槓しています。", kangPlayer, getNumberOfQuads(GameStat, kangPlayer), getTotalKang(GameStat))
		}
	}
	/* 事後処理 */
	repeat NUM_OF_PLAYERS: setCall cnt, "": loop
	/* 再描画 */
	redrscreen
	/* 鳴きが成立したので、一発のフラグを降ろす */
	repeat NUM_OF_PLAYERS
		if (getRichiFlag(GameStat, RICHI_FLAG, cnt) == RIICHI_IPPATSU) {setRichiFlag GameStat, RICHI_FLAG, cnt, RIICHI_YES}
		if (getRichiFlag(GameStat, RICHI_FLAG, cnt) == RIICHI_DOUBLE_IPPATSU) {setRichiFlag GameStat, RICHI_FLAG, cnt, RIICHI_DOUBLE}
		setFirstDrawFlag GameStat, cnt, 0
	loop
	return 0
#global

/* 包を判定する */
#module
#include "const.as"
#deffunc checkpao var GameStat, int PassivePlayer, int ActivePlayer
	// 包の判定 ここから
	debug "包の条件を判定します。"
	DragonPons = 0: WindPons = 0: NumOfKangs = 0
	repeat MeldPointer(GameStat, PassivePlayer), 1
		if (((getMeld(GameStat, MELD_TILECODE, cnt , PassivePlayer)\TILE_CODE_MAXIMUM) >= TILE_DRAGON_MIN)&&((getMeld(GameStat, MELD_TILECODE, cnt , PassivePlayer)\TILE_CODE_MAXIMUM) <= TILE_DRAGON_MAX)) {
			DragonPons++
		}
		if (((getMeld(GameStat, MELD_TILECODE, cnt , PassivePlayer)\TILE_CODE_MAXIMUM) >= TILE_WIND_MIN)&&((getMeld(GameStat, MELD_TILECODE, cnt , PassivePlayer)\TILE_CODE_MAXIMUM) <= TILE_WIND_MAX)) {
			WindPons++
		}
		if ((getMeld(GameStat, MELD_TILECODE, cnt , PassivePlayer)/MELD_TYPE_STEP) >= MELD_QUAD) {
			NumOfKangs++
		}
	loop
	if (getRule(RULE_NORMAL_PAO) == 0) {
		if ((DragonPons == 3)&&(getPao(GameStat, PAO_PLAYER_PAO, PAO_YAKU_DAISANGEN) == -1)) {
			debug strf("プレイヤー [%d] は、大三元を包になります。", kangPlayer)
			setPao GameStat, PAO_PLAYER_PAO, PAO_YAKU_DAISANGEN, ActivePlayer
			setPao GameStat, PAO_PLAYER_AGARI, PAO_YAKU_DAISANGEN, PassivePlayer
		}
		if ((WindPons == 4)&&(getPao(GameStat, PAO_PLAYER_PAO, PAO_YAKU_DAISIXI) == -1)) {
			debug strf("プレイヤー [%d] は、大四喜を包になります。", kangPlayer)
			setPao GameStat, PAO_PLAYER_PAO, PAO_YAKU_DAISIXI, ActivePlayer
			setPao GameStat, PAO_PLAYER_AGARI, PAO_YAKU_DAISIXI, PassivePlayer
		}
	}
	if ((getRule(RULE_SUUKANTSU) >= 2)&&(NumOfKangs == 4)&&(getPao(GameStat, PAO_PLAYER_PAO, PAO_YAKU_SIKANG) == -1)) {
		debug strf("プレイヤー [%d] は、四槓子を包になります。", kangPlayer)
		setPao GameStat, PAO_PLAYER_PAO, PAO_YAKU_SIKANG, ActivePlayer
		setPao GameStat, PAO_PLAYER_AGARI, PAO_YAKU_SIKANG, PassivePlayer
	}
	// 包の判定 ここまで
	return
#global

/* 栄和のときの処理 */
*ronhuproc
	info "リアクションを問い合わせます。"
	/* 栄和や鳴き仕掛けをするかどうか問い合わせる */
	resetDeclarationFlag GameStat
	dim MinkanFlag, NUM_OF_PLAYERS: dim ChiFlag, NUM_OF_PLAYERS
	repeat NUM_OF_PLAYERS
		if (ActivePlayer != cnt) {
			PassivePlayer = cnt
			if (PassivePlayer == getPlayer(GameStat)) {
				playerfuuro GameStat, GameEnv, ActivePlayer, PassivePlayer, MinkanFlag, ChiFlag
			} else {
				if (IsRemotePlayer(GameEnv, PassivePlayer) == 0) {
					/* COMが「カンニング」しないように処理 */
					makesandbox Sandbox, GameStat, PassivePlayer
					dim reducedMinkan, NUM_OF_PLAYERS: dim reducedChi, NUM_OF_PLAYERS
					/* 処理 */
					compfuuro Sandbox, PassivePlayer, MinkanFlag, ChiFlag
					repeat NUM_OF_PLAYERS
						if (getDeclarationFlag(GameStat, DECLARATIONFLAG_RON, cnt) == 0) {setDeclarationFlag GameStat, DECLARATIONFLAG_RON, cnt, getDeclarationFlag(Sandbox, DECLARATIONFLAG_RON, cnt)}
						if (MinkanFlag(cnt) == 0) {MinkanFlag(cnt) = reducedMinkan(cnt)}
						if (getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, cnt) == 0) {setDeclarationFlag GameStat, DECLARATIONFLAG_PON, cnt, getDeclarationFlag(Sandbox, DECLARATIONFLAG_PON, cnt)}
						if (ChiFlag(cnt) == 0) {ChiFlag(cnt) = reducedChi(cnt)}
					loop
				}
			}
		} else {
			if (cnt == getPlayer(GameStat)) {
				if (getGameMode(GameEnv) == GAMEMODE_CLIENT) {clientsend 0xa0}
			}
		}
	loop
	/* 通信対戦時の処理 */
	if (getGameMode(GameEnv) != GAMEMODE_STANDALONE) {
		remotenaki GameStat, GameEnv, MinkanFlag, ChiFlag
	}
	if (getGameMode(GameEnv) == GAMEMODE_CLIENT) {
		if (ReceivedMsg == 1023) {
			setCenterTitle "回線切断": redrscreen
			gosub *reconnection
			dialog "再接続しました\nこの回は和了り放棄になります\n次の局から参加可能です", 0, "回線切断"
			RoundEndType = 9
			return
		}
	}
	trace strf("ロン [%d %d %d %d] カン [%d %d %d %d] ポン [%d %d %d %d] チー [%d %d %d %d]", getDeclarationFlag(GameStat, DECLARATIONFLAG_RON, 0),getDeclarationFlag(GameStat, DECLARATIONFLAG_RON, 1),getDeclarationFlag(GameStat, DECLARATIONFLAG_RON, 2),getDeclarationFlag(GameStat, DECLARATIONFLAG_RON, 3),MinkanFlag(0),MinkanFlag(1),MinkanFlag(2),MinkanFlag(3),getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 0),getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 1),getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 2),getDeclarationFlag(GameStat, DECLARATIONFLAG_PON, 3),ChiFlag(0),ChiFlag(1),ChiFlag(2),ChiFlag(3))
	/* 和了り放棄の時は宣言を無効にする */
	repeat NUM_OF_PLAYERS
		if (getAgariHouki(GameStat, cnt) == 1) {
			debug strf("プレイヤー [%d] は和了り放棄です。宣言フラグを下ろします。", cnt)
			setDeclarationFlag GameStat, DECLARATIONFLAG_RON, cnt, 0: setDeclarationFlag GameStat, DECLARATIONFLAG_PON, cnt, 0
			ChiFlag(cnt) = 0: MinkanFlag(cnt) = 0
		}
	loop
	/* ロンしようとする人を表示(頭ハネで蹴られるような人も含む) */
	repeat NUM_OF_PLAYERS
		if (getDeclarationFlag(GameStat, DECLARATIONFLAG_RON, cnt) == 1) {
			debug strf("プレイヤー [%d] は、栄和を宣言します。", cnt)
			// 優先権のないロンも表示されるようにする
			setCall cnt, " ロン "
			setHandStat GameStat, cnt, 1
		}
	loop
	/* 実際にロンできる人を表示 */
	roncount = 0: repeat NUM_OF_PLAYERS-1
		if (getDeclarationFlag(GameStat, DECLARATIONFLAG_RON, RelativePositionOf(ActivePlayer, cnt+1)) == 1) {
			if (roncount == 0) {
				debug strf("プレイヤー [%d] は、栄和できます。", RelativePositionOf(ActivePlayer, cnt+1))
				setCall RelativePositionOf(ActivePlayer, cnt+1), "ロン"
			}
			if ((roncount == 1)&&(getRule(RULE_MULTIPLE_MAHJONG) >= 2)) {
				debug strf("プレイヤー [%d] は、栄和できます。", RelativePositionOf(ActivePlayer, cnt+1))
				setCall RelativePositionOf(ActivePlayer, cnt+1), "ロン"
			}
			if ((roncount == 2)&&(getRule(RULE_MULTIPLE_MAHJONG) == 4)) {
				debug strf("プレイヤー [%d] は、栄和できます。", RelativePositionOf(ActivePlayer, cnt+1))
				setCall RelativePositionOf(ActivePlayer, cnt+1), "ロン"
			}
			roncount++
		}
	loop
	/* 実際に栄和を行なう処理 */
	repeat NUM_OF_PLAYERS-1
		await 0
		if (getDeclarationFlag(GameStat, DECLARATIONFLAG_RON, RelativePositionOf(ActivePlayer, cnt+1)) == 1) {
			/* ウォッチモードの場合は和了った人に視点を向ける */
			if (GetWatchModeFlag(GameEnv) == 1) {
				setPlayer GameStat, RelativePositionOf(ActivePlayer, cnt+1)
			}
			/* 栄和したことを変数に記録 */
			RoundEndType = ENDKYOKU_AGARI: setTsumoAgariFlag GameStat, 0
			furikomiPlayer = ActivePlayer
			agariPlayer = RelativePositionOf(ActivePlayer, cnt+1)
			/* 八連荘の判定に使う変数 */
			if (getRule(RULE_PAARENCHAN) != 0) {
				if (getLastAgariPlayer(GameStat) == agariPlayer) {
					incAgariChain GameStat
				} else {
					if ((getRule(RULE_BREAKING_PAARENCHAN) != 0)&&(getAgariChain(GameStat) == 7)) {setAgariChain GameStat, -1: setLastAgariPlayer GameStat, agariPlayer}
					else {setAgariChain GameStat, 1: setLastAgariPlayer GameStat, agariPlayer}
				}
			}
			/* 和了り牌を設定 */
			setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, agariPlayer, getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
			setHand GameStat, HAND_REDTILE, TSUMOHAI_INDEX, agariPlayer, getCurrentDiscard(GameStat, CURRENTDISCARD_REDTILE)
			if (getRichiFlag(GameStat, RICHI_FLAG, ActivePlayer) == RIICHI_IPPATSU) {setRichiFlag GameStat, RICHI_FLAG, ActivePlayer, RIICHI_NO: addDeposit GameStat, -1: addScore GameStat, ActivePlayer, 0, 10: setRichiCounterFlag GameStat, 1}
			if (getRichiFlag(GameStat, RICHI_FLAG, ActivePlayer) == RIICHI_DOUBLE_IPPATSU) {setRichiFlag GameStat, RICHI_FLAG, ActivePlayer, RIICHI_NO: addDeposit GameStat, -1: addScore GameStat, ActivePlayer, 0, 10: setRichiCounterFlag GameStat, 2}
			/* 役や振聴の判定 */
			countyaku GameStat, yakuInfo, RelativePositionOf(ActivePlayer, cnt+1), furikomiPlayer
			chkfuriten FuritenFlag, MachihaiFlag, MachihaiCount, MachihaiTotal, MachiMen, GameStat, RelativePositionOf(ActivePlayer, cnt+1)
			// 縛りを満たさないか、振聴のとき
			if ((getYakuInfo(yakuInfo, YAKUINF_HAN_BASE) <= getShibari(GameStat))||(FuritenFlag == 1)||(getDoujunFuriten(GameStat, agariPlayer) == 1)||((getRule(RULE_RIICHI_SHIBARI) != 0)&&(getRichiFlag(GameStat, RICHI_FLAG, agariPlayer) == RIICHI_NO))) {
				trace "縛りを満たさないか振聴です。次の処理をチョンボ用に切り替えます。"
				RoundEndType = ENDKYOKU_CHONBO // チョンボにする
			}
			// ロンをしたことを表示
			//setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, agariPlayer, getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
			//setHand GameStat, HAND_REDTILE, TSUMOHAI_INDEX, agariPlayer, getCurrentDiscard(GameStat, CURRENTDISCARD_REDTILE)
			setCall agariPlayer, "ロン"
			setHandStat GameStat, agariPlayer, 1
			/* 立直宣言牌での放銃の場合、立直を無効とし供託点棒を返却する */
			if (getRichiFlag(GameStat, RICHI_FLAG, ActivePlayer) == RIICHI_IPPATSU) {
				trace "立直宣言牌での放銃のため、立直棒を返還します。"
				setRichiFlag GameStat, RICHI_FLAG, ActivePlayer, RIICHI_NO: addDeposit GameStat, -1: addScore GameStat, ActivePlayer, 0, 10: setRichiCounterFlag GameStat, 1
			}
			if (getRichiFlag(GameStat, RICHI_FLAG, ActivePlayer) == RIICHI_DOUBLE_IPPATSU) {
				trace "ダブル立直宣言牌での放銃のため、立直棒を返還します。"
				setRichiFlag GameStat, RICHI_FLAG, ActivePlayer, RIICHI_NO: addDeposit GameStat, -1: addScore GameStat, ActivePlayer, 0, 10: setRichiCounterFlag GameStat, 2
			}
			/* 和了り牌を設定 */
			setHand GameStat, HAND_TILECODE, TSUMOHAI_INDEX, agariPlayer, getCurrentDiscard(GameStat, CURRENTDISCARD_TILECODE)
			setHand GameStat, HAND_REDTILE, TSUMOHAI_INDEX, agariPlayer, getCurrentDiscard(GameStat, CURRENTDISCARD_REDTILE)
			/* 栄和のサウンドを鳴らす */
			if (ActivePlayer == getPlayer(GameStat)) {
				dsplay VOX_RON_FURIKOMI
			} else {
				dsplay VOX_RON
			}
			/* 画面更新して戻る */
			redrscreen
			break
		}
	loop
	/* 牌譜に記録 */
	roncount = 0
	if (RonPlayers(GameStat) > 0) {
		if (getKangFlag(GameStat, KANG_CHANKAN) > 0) {
#ifdef SANMAX
			if (DiscardTileIndex/PassivePlayer == DAHAI_TYPE_FLOWER/PassivePlayer) {
				haifurecchanpei ActivePlayer
			} else {
#endif
				haifurecchankan ActivePlayer
#ifdef SANMAX
			}
#endif
		} else {
			haifurecfurikomi GameStat, ActivePlayer
		}
	} else {
		if (getKangFlag(GameStat, KANG_FLAG) == 0) { // 抜き北で牌譜がずれるのを抑止
			haifurecfurikomi GameStat, ActivePlayer
		}
	}
#ifdef ALLSANMA
	// 二家和の判定
	if ((RonPlayers(GameStat) >= 2)&&(getRule(RULE_MULTIPLE_MAHJONG)==5)) {
		RoundEndType = ENDKYOKU_TRIPLERON: return
	}
#else
	// 三家和の判定
	if ((RonPlayers(GameStat) >= 3)&&((getRule(RULE_MULTIPLE_MAHJONG)==0)||(getRule(RULE_MULTIPLE_MAHJONG)==2))) {
		RoundEndType = ENDKYOKU_TRIPLERON: return
	}
#endif
return
